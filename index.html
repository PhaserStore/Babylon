<!doctype html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Virtual Gallery ‚Äî Clean View + SoundCloud Bar</title>

  <!-- ‚úÖ Poppins font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
<link href="https://fonts.googleapis.com/css2?family=Doto:wght@700&display=swap" rel="stylesheet" />
  <style>
    :root{
      --txt:#fff; --txt-dim:#ccc;
      --safe-top: env(safe-area-inset-top);
      --safe-right: env(safe-area-inset-right);
      --safe-bottom: env(safe-area-inset-bottom);
      --safe-left: env(safe-area-inset-left);
      --bar-h: 54px;
      --btn-bg:#2b2b2b;
      --btn-bg-hover:#3a3a3a;
      --btn-brd:rgba(255,255,255,.15);
      --accent:#ff6a00;
    }
    html,body{
      width:100%;height:100%;margin:0;overflow:hidden;background:#111;
      font-family:'Poppins',system-ui,Segoe UI,Roboto,Arial,sans-serif;color:var(--txt);
    }
    #renderCanvas{
      position:fixed; inset:0; display:block; touch-action:none; width:100vw; height:100vh;
      will-change: transform; transform: translateZ(0);
    }

    /* === SoundCloud full-width bottom bar === */
    #scBar{
      position:fixed; left:0; right:0; bottom:0;
      height:var(--bar-h); background:#1a1a1a;
      border-top:1px solid rgba(255,255,255,.15);
      display:flex; align-items:center; padding:0 14px; gap:20px;
      z-index:50; font-size:13px; color:#eee; font-family:'Poppins', sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    #scBar button{
      width:34px; height:34px; border-radius:8px;
      border:1px solid var(--btn-brd);
      background:var(--btn-bg); color:#fff; cursor:pointer;
      display:inline-grid; place-items:center;
      outline: none;
    }
    #scBar button:hover{ background:var(--btn-bg-hover); }
    #scBar button:focus-visible{ box-shadow: 0 0 0 2px rgba(255,255,255,.25); }
    .icon{ width:18px; height:18px; display:block; fill:#fff; pointer-events:none; }

    .sc-left{ display:flex; gap:6px; align-items:center; }

    /* progress bar */
    .sc-center{ flex:1; display:flex; align-items:center; gap:10px; user-select:none; min-width:180px; }
    #scSeek{ flex:1; height:6px; background:#555; border-radius:4px; position:relative; cursor:pointer; }
    #scSeekFill{ position:absolute; left:0; top:0; bottom:0; width:0%; background:var(--accent); border-radius:4px; }
    .time{ min-width:40px; text-align:center; color:#ddd; font-variant-numeric: tabular-nums; }

    .sc-right{ display:flex; align-items:center; gap:12px; min-width:280px; }
    #scThumb{ width:34px; height:34px; border-radius:6px; object-fit:cover; }
    #barVol{ width:84px; }

    /* Ikony vpravo dole nad barem */
    .hudIcon{
      position:fixed;
      z-index:10000;
      width:56px; height:56px;
      cursor:pointer; user-select:none; -webkit-user-drag:none;
      filter: drop-shadow(0 8px 16px rgba(0,0,0,.45));
      opacity:.96; transition: transform .12s ease, opacity .12s ease;
      right:calc(12px + var(--safe-right));
      bottom:calc(12px + var(--bar-h) + var(--safe-bottom));
    }
    .hudIcon:hover{ transform:translateY(-1px); opacity:1; }

    /* üîß Fullscreen vlevo od resetu, na stejn√© ‚Äûlinii‚Äú (n√≠≈æe u bar/Focus) */
    #fullscreenIcon{
      right:calc(12px + var(--safe-right) + 56px + 8px); /* 8px mezera, vlevo od resetu */
    }

    /* Skryj fullscreen ikonu na mobilu */
    @media (pointer:coarse), (max-width: 900px){
      #fullscreenIcon{ display:none !important; }
    }

    /* Mobiln√≠ √∫pravy li≈°ty */
    @media (max-width: 560px){
      #scBar{ gap:12px; padding:0 10px; }
      .sc-right{ min-width:200px; gap:10px; }
      #barVol{ width:70px; }
      .time{ display:none; }
    }
  </style>

  <!-- ‚úÖ Babylon.js + GUI -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <!-- ‚ö†Ô∏è SoundCloud API naƒçtu a≈æ p≈ôi Play -->
</head>

<body>
  <!-- ===== Canvas ===== -->
  <canvas id="renderCanvas"></canvas>

  <!-- üîß Fullscreen (vlevo), Reset (vpravo) ‚Äì stejn√° spodn√≠ linie -->
  <img
    id="fullscreenIcon"
    class="hudIcon"
    src="https://raw.githubusercontent.com/PhaserStore/Babylon/main/assets/full%20screen.svg"
    alt="Cel√° obrazovka"
    title="P≈ôepnout cel√© okno"
    role="button"
    tabindex="0"
    aria-label="Cel√° obrazovka"
    aria-pressed="false"
  />
  <img
    id="resetCamIcon"
    class="hudIcon"
    src="./assets/focus.svg"
    alt="Reset kamery"
    title="Reset kamery"
    role="button"
    tabindex="0"
    aria-label="Reset kamery"
  />

  <!-- === Fullscreen bottom SoundCloud bar === -->
  <div id="scBar" aria-label="SoundCloud Bar">
    <div class="sc-left">
      <button id="barPrev" title="Previous" aria-label="Previous">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M11 6v12l-8-6 8-6zm10 0v12l-8-6 8-6z"/></svg>
      </button>
      <button id="barPlay" title="Play" aria-label="Play">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M8 5v14l11-7z"/></svg>
      </button>
      <button id="barPause" title="Pause" aria-label="Pause">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 5h4v14H6zM14 5h4v14h-4z"/></svg>
      </button>
      <button id="barNext" title="Next" aria-label="Next">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M13 6v12l8-6-8-6zM3 6v12l8-6-8-6z"/></svg>
      </button>
    </div>

    <div class="sc-center">
      <span id="scTimeCur" class="time">0:00</span>
      <div id="scSeek" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" tabindex="0">
        <div id="scSeekFill"></div>
      </div>
      <span id="scTimeDur" class="time">0:00</span>
    </div>

    <div class="sc-right">
      <button id="barMute" title="Mute/Unmute" aria-label="Mute or unmute">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 9v6h4l5 5V4L8 9H4z"/></svg>
      </button>
      <input id="barVol" type="range" min="0" max="100" value="75" aria-label="Volume" />
      <img id="scThumb" src="" alt="cover" />
      <span id="scTitle">‚Äì</span>
    </div>
  </div>

  <!-- Skryt√Ω host pro SC iframe -->
  <div id="scIframeHost" style="display:none"></div>

  <!-- ===== Hlavn√≠ skript ===== -->
  <script>
  "use strict";

  /* =========================
     Pomocn√©
  ========================= */
  const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || Math.min(window.innerWidth, window.innerHeight) <= 900;
  const IS_IOS = /iP(ad|hone|od)/.test(navigator.userAgent);

  function fmtTime(ms){
    const sec = Math.max(0, Math.floor((ms||0)/1000));
    const m = Math.floor(sec/60), s = sec%60;
    return `${m}:${s.toString().padStart(2,'0')}`;
  }
  function snapDpr(raw) {
    const v = Math.max(1, Math.min(raw || 1, 3));
    const steps = [1, 1.25, 1.5, 2, 2.5, 3];
    let pick = steps[0], best = Infinity;
    for (const s of steps){ const d = Math.abs(s - v); if (d < best){ best = d; pick = s; } }
    return pick;
  }
  const DPR_RAW = window.devicePixelRatio || 1;
  const DPR = snapDpr(DPR_RAW);

  /* =========================
     Babylon init
  ========================= */
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, {
    preserveDrawingBuffer:false, stencil:true, antialias:true, adaptToDeviceRatio:false,
    powerPreference: "high-performance"
  });
  if (!window.BABYLON) { console.error("Babylon.js se nenaƒçetl."); }

  const CAPS = engine.getCaps ? engine.getCaps() : {};
  const MAX_TEX_CAP = Math.max(512, CAPS.maxTextureSize || 2048);
  const MOBILE_TEX_CAP  = Math.min(MAX_TEX_CAP, 1024);
  const DESKTOP_TEX_CAP = Math.min(MAX_TEX_CAP, 4096);
  const TEX_BASE = IS_MOBILE ? 1024 : 2048;
  let TEX_SIZE = Math.round(TEX_BASE * Math.min(DPR, 2));
  TEX_SIZE = nearestPOT(Math.min(TEX_SIZE, IS_MOBILE ? MOBILE_TEX_CAP : DESKTOP_TEX_CAP), IS_MOBILE ? MOBILE_TEX_CAP : DESKTOP_TEX_CAP);
  const MAX_ANISO = CAPS.maxAnisotropy || 4;

  function nearestPOT(n, cap){
    const p = Math.pow(2, Math.round(Math.log2(Math.max(2, n))));
    return Math.min(p, cap || p);
  }

  let scene, camera, glow, hl;

  const ROOM = { W: 16, D: 30, H: 13 };
  const MIN_RADIUS = 0.28;
  const MAX_RADIUS = 40;

  // HW scale
  const BASE_LEVEL = Math.max(0.33, Math.min(1 / DPR, 1));
  let currentScaleLevel = Math.round(BASE_LEVEL * 100) / 100;
  function applyHardwareScale(levelOverride){
    const lvl = typeof levelOverride === "number" ? levelOverride : currentScaleLevel;
    engine.setHardwareScalingLevel(Math.round(lvl * 100) / 100);
  }
  applyHardwareScale();

  // mobiln√≠ auto-scale (jemn√Ω)
  const AutoScale = {
    enabled: IS_MOBILE,
    windowMs: 1200,
    warmupMs: 1500,
    lowFpsMs: 30,
    highFpsMs: 17,
    step: 0.05,
    minLevel: 0.33,
    maxLevel: 1.00,
    accMs: 0, frames: 0, lastEval: performance.now()
  };
 

  function createScene(){
  scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(0,0,0,1);

  camera = new BABYLON.ArcRotateCamera(
    "cam", -Math.PI/2, Math.PI/2.25, 11.5,
    new BABYLON.Vector3(0, ROOM.H*0.48, 0),
    scene
  );
  camera.attachControl(canvas, true);
  camera.minZ = 0.2;
  camera.maxZ = 5000;     // skybox je ob≈ô√≠, mal√Ω dohled by ho ‚Äûu≈ôezal‚Äú

  new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);

  // (voliteln√©) zjemni glow, a≈• naho≈ôe nep≈ôebije oblohu
  glow = new BABYLON.GlowLayer("gl", scene, { blurKernelSize: IS_MOBILE ? 16 : 28 });
  glow.intensity = IS_MOBILE ? 0.45 : 0.65;

  // hned po createScene()
scene.imageProcessingConfiguration.toneMappingEnabled = false;
scene.imageProcessingConfiguration.exposure = 1.0;
// d≈Øle≈æit√© ‚Äì a≈• se ImageProcessing neaplikuje jako post-process:
scene.imageProcessingConfiguration.applyByPostProcess = false;

// pro jistotu standardizuj gamma
scene.imageProcessingConfiguration.contrast = 1.0;
scene.imageProcessingConfiguration.isEnabled = true; // ale bez post-processu

  buildRoom();
buildLED();
// buildCeilingLip();  // voliteln√©
buildGalleryLogo();
buildMySkybox();       // ‚¨ÖÔ∏è m√≠sto p≈Øvodn√≠ho skyboxu/skydome
buildCeilingWithAperture({ inw: 0.1 });


  setupPicking();
  setupZoomUX();
  return scene;
}
    function buildCeilingWithAperture({ inw = 0.1, lip = 0.001 } = {}) {
  // V√Ω≈°ka stropu ‚Äì podle horn√≠ho LED (y1 = ROOM.H - 0.04)
  const y1 = ROOM.H - 0.04;
  const yCeil = y1 + 0.0005; // nepatrnƒõ nad LED, aby nebyl z-fighting

  // Celkov√Ω stropn√≠ rozmƒõr
  const W = ROOM.W, D = ROOM.D;

  // Vnit≈ôn√≠ ‚Äûƒçist√Ω‚Äú otvor podle LED
  const openW = W - 2 * inw;
  const openD = D - 2 * inw;

  // Materi√°l stropu (neutr√°ln√≠, unlit)
  const mCeil = unlit("#111111");

  // ƒåty≈ôi kusy ‚Äûstropn√≠ch desek‚Äú kolem otvoru (sever/jih/v√Ωchod/z√°pad)
  // 1) Severn√≠ deska (nad zadn√≠ stƒõnou)
  const north = BABYLON.MeshBuilder.CreatePlane("ceil_north", {
    width: W,
    height: (D - openD) / 2,
    sideOrientation: BABYLON.Mesh.FRONTSIDE
  }, scene);
  north.position.set(0, yCeil, -(openD / 2 + (D - openD) / 4));
  north.rotation.x = Math.PI / 2;
  north.material = mCeil;
  north.isPickable = false;

  // 2) Ji≈æn√≠ deska (nad p≈ôedn√≠ stƒõnou)
  const south = BABYLON.MeshBuilder.CreatePlane("ceil_south", {
    width: W,
    height: (D - openD) / 2,
    sideOrientation: BABYLON.Mesh.FRONTSIDE
  }, scene);
  south.position.set(0, yCeil, +(openD / 2 + (D - openD) / 4));
  south.rotation.x = Math.PI / 2;
  south.material = mCeil;
  south.isPickable = false;

  // 3) Z√°padn√≠ deska (nad levou stƒõnou)
  const west = BABYLON.MeshBuilder.CreatePlane("ceil_west", {
    width: (W - openW) / 2,
    height: openD,
    sideOrientation: BABYLON.Mesh.FRONTSIDE
  }, scene);
  west.position.set(-(openW / 2 + (W - openW) / 4), yCeil, 0);
  west.rotation.x = Math.PI / 2;
  west.material = mCeil;
  west.isPickable = false;

  // 4) V√Ωchodn√≠ deska (nad pravou stƒõnou)
  const east = BABYLON.MeshBuilder.CreatePlane("ceil_east", {
    width: (W - openW) / 2,
    height: openD,
    sideOrientation: BABYLON.Mesh.FRONTSIDE
  }, scene);
  east.position.set(+(openW / 2 + (W - openW) / 4), yCeil, 0);
  east.rotation.x = Math.PI / 2;
  east.material = mCeil;
  east.isPickable = false;

  // Voliteln√Ω ‚Äûvnit≈ôn√≠ svisl√Ω l√≠mec‚Äú otvoru (ƒçist√° hrana stropu pod√©l LED)
  const lipH = 0.02; // ~2 cm
  const mLip = unlit("#181818");

  const mkLip = (name, w, h, px, pz, rotY = 0) => {
    const p = BABYLON.MeshBuilder.CreatePlane(name, {
      width: w, height: h, sideOrientation: BABYLON.Mesh.BACKSIDE
    }, scene);
    p.position.set(px, y1 - lipH / 2, pz);
    p.rotation.y = rotY;
    p.material = mLip;
    p.isPickable = false;
    return p;
  };

  // L√≠mce na v≈°ech ƒçty≈ôech stran√°ch otvoru
  mkLip("lip_north", openW, lipH, 0, -openD/2, 0);
  mkLip("lip_south", openW, lipH, 0,  openD/2, Math.PI);
  mkLip("lip_west",  openD, lipH, -openW/2, 0, -Math.PI/2);
  mkLip("lip_east",  openD, lipH,  openW/2, 0,  Math.PI/2);

  // Volitelnƒõ: Pokud chce≈° fotopanel p≈ôesnƒõ v otvoru (m√≠sto oblohy):
  // buildCeilingPhoto("./assets/yourCeilingPhoto.jpg", { bleed: 0.003, texSize: 2048, fit: "cover" });
}

// --- MATERI√ÅLY (vlo≈æit nad buildRoom) --------------------------------------

function unlit(hex){
  const m = new BABYLON.StandardMaterial("m", scene);
  m.diffuseColor    = BABYLON.Color3.FromHexString(hex);
  m.disableLighting = true;
  m.backFaceCulling = false;           // kreslit i zadn√≠ stranu (z interi√©ru m√≠stnosti)
  m.specularColor   = new BABYLON.Color3(0,0,0);
  return m;
}

function unlitTex(tex, { doubleSided=false } = {}){
  const m = new BABYLON.StandardMaterial("mt", scene);
  m.disableLighting   = true;
  m.diffuseTexture    = tex;
  m.emissiveTexture   = tex;
  m.backFaceCulling   = !doubleSided;
  m.specularColor     = new BABYLON.Color3(0,0,0);
  if (tex){
    tex.wrapU = tex.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
    tex.updateSamplingMode(BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
    tex.anisotropicFilteringLevel = (engine.getCaps()?.maxAnisotropy || 4);
  }
  return m;
}
// === P≈ôesn√° stropn√≠ fotografie uvnit≈ô LED r√°mu =============================
function buildCeilingPhoto(url, { bleed = 0.002, texSize = 2048, fit = "cover" } = {}){
  // Rozmƒõr otvoru z tv√©ho buildLED: inw = 0.1; horn√≠ LED v√Ω≈°ka y1 = ROOM.H - 0.04
  const INSET = 0.1;
  const yTop  = ROOM.H - 0.04;
  const y     = yTop - 0.001; // nepatrnƒõ pod LED, aby nebyl z-fighting

  // Vnit≈ôn√≠ ≈°√≠≈ôka/hloubka (lehce "p≈ôesah" - bleed), a≈• nen√≠ vidƒõt sp√°ra
  const w = (ROOM.W - 2*INSET) + bleed*2;
  const d = (ROOM.D - 2*INSET) + bleed*2;

  // 1) Plocha ‚Äì le≈æ√≠ vodorovnƒõ, uprost≈ôed otvoru, viditeln√° z obou stran
  const plane = BABYLON.MeshBuilder.CreatePlane("ceilingPhoto", {
    width: w, height: d, sideOrientation: BABYLON.Mesh.DOUBLESIDE
  }, scene);
  plane.position.set(0, y, 0);
  plane.rotation.x = Math.PI / 2;         // vodorovnƒõ
  plane.isPickable = false;

  // 2) Dynamick√° textura ‚Äì slu≈°n√Ω ‚Äûcover/contain‚Äú fit bez deformace
  const dt  = new BABYLON.DynamicTexture("ceilingDT",
    { width: texSize, height: texSize }, scene, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
  const ctx = dt.getContext();
  ctx.fillStyle = "#000"; ctx.fillRect(0,0,texSize,texSize);

  const img = new Image();
  img.decoding = "async";
  img.onload = () => {
    const r = img.width / img.height;
    const targetR = w / d;

    let dw, dh, dx = 0, dy = 0;
    if (fit === "cover"){
      // vypln√≠me plochu a p≈ô√≠padnƒõ zhorn√≠me/zbok≈Ø o≈ô√≠zneme
      if (r > targetR){ dh = texSize; dw = Math.round(dh * r); dx = Math.round((texSize - dw)/2); }
      else            { dw = texSize; dh = Math.round(dw / r); dy = Math.round((texSize - dh)/2); }
    } else {
      // contain ‚Äì bez o≈ôezu, kolem dopln√≠me ƒçernou
      if (r > targetR){ dw = texSize; dh = Math.round(dw / r); dy = Math.round((texSize - dh)/2); }
      else            { dh = texSize; dw = Math.round(dh * r); dx = Math.round((texSize - dw)/2); }
    }

    ctx.imageSmoothingEnabled  = true;
    ctx.imageSmoothingQuality  = "high";
    ctx.drawImage(img, 0, 0, img.width, img.height, dx, dy, dw, dh);
    dt.update();
  };
  img.src = url;

  const mat = new BABYLON.StandardMaterial("ceilingMat", scene);
  mat.disableLighting   = true;
  mat.backFaceCulling   = false;             // viditeln√© i p≈ôi vytoƒçen√≠ kamery
  mat.diffuseTexture    = dt;
  mat.emissiveTexture   = dt;                // ‚Äûsv√≠t√≠‚Äú sama ‚Äì ≈æ√°dn√© ztmavnut√≠
  mat.specularColor     = new BABYLON.Color3(0,0,0);
  dt.wrapU = dt.wrapV   = BABYLON.Texture.CLAMP_ADDRESSMODE;
  plane.material        = mat;

  // Pro jistotu dr≈æ√≠me plochu mimo Glow ‚Äûincluded only‚Äú
  try { glow?.removeIncludedOnlyMesh?.(plane); } catch (e) {}
  return plane;
}
function buildMySkybox() {
  // Velk√° krychle vykreslovan√° zevnit≈ô
  const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 2000 }, scene);
  skybox.isPickable = false;
  skybox.infiniteDistance = true;

  // Materi√°l pro skybox
  const skyMat = new BABYLON.StandardMaterial("skyMat", scene);
  skyMat.backFaceCulling = false;
  skyMat.disableLighting = true;
  skyMat.diffuseColor  = new BABYLON.Color3(0,0,0);
  skyMat.specularColor = new BABYLON.Color3(0,0,0);

  // v buildMySkybox(), po vytvo≈ôen√≠ skyMat:
skyMat.emissiveColor = new BABYLON.Color3(0.10, 0.10, 0.10); // jemnƒõ projasn√≠ - klidnƒõ 0.08‚Äì0.15
skybox.applyFog = false;

  // ‚¨áÔ∏è Explicitnƒõ zad√°me 6 PNG soubor≈Ø (≈æ√°dn√© 404, ≈æ√°dn√© .jpg defaulty)
const cubetex = BABYLON.CubeTexture.CreateFromImages([
  "./assets/mySky_px.png",
  "./assets/mySky_nx.png",
  "./assets/mySky_py.png",
  "./assets/mySky_ny.png",
  "./assets/mySky_pz.png",
  "./assets/mySky_nz.png"
], scene);

cubetex.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
cubetex.updateSamplingMode(BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
cubetex.gammaSpace = true;           
cubetex.lodGenerationOffset = 0;
cubetex.lodGenerationScale  = 0;

skyMat.reflectionTexture = cubetex;
skyMat.emissiveColor = new BABYLON.Color3(0.10, 0.10, 0.10);
skybox.material = skyMat;

  // (Volitelnƒõ) pootoƒçen√≠ skyboxu, pokud chce≈° ‚Äûotoƒçit‚Äú hvƒõzdnou mapu
  // skybox.rotation.y = Math.PI / 2;
}
 function buildRoom() {
  const floor = BABYLON.MeshBuilder.CreateGround("floor", { 
    width: ROOM.W, 
    height: ROOM.D 
  }, scene);
  floor.material = unlit("#151515");

  // Horn√≠ LED: ve tv√©m buildLED() je y1 = ROOM.H - 0.04
  const LED_TOP = ROOM.H - 0.04;

  // Stƒõny konƒç√≠ tƒõsnƒõ pod LED
  const LIP = 0.005;
  const WALL_H = LED_TOP - LIP;
  const wallY  = WALL_H / 2;

  // Mal√© p≈ôekryt√≠ do roh≈Ø (eliminuje mikro sp√°ry)
  const OVER = 0.04; // ~4 cm

  // ZADN√ç stƒõna
  const back = BABYLON.MeshBuilder.CreatePlane("back", {
    width: ROOM.W + OVER,
    height: WALL_H,
    sideOrientation: BABYLON.Mesh.FRONTSIDE
  }, scene);
  back.position.set(0, wallY, -ROOM.D/2);
  back.material = unlit("#2b2b2b");

  // P≈òEDN√ç stƒõna
  const front = BABYLON.MeshBuilder.CreatePlane("front", {
    width: ROOM.W + OVER,
    height: WALL_H,
    sideOrientation: BABYLON.Mesh.FRONTSIDE
  }, scene);
  front.position.set(0, wallY, ROOM.D/2);
  front.rotation.y = Math.PI;
  front.material = unlit("#2b2b2b");

  // LEV√Å stƒõna
  const left = BABYLON.MeshBuilder.CreatePlane("leftWall", {
    width: ROOM.D + OVER,
    height: WALL_H,
    sideOrientation: BABYLON.Mesh.FRONTSIDE
  }, scene);
  left.position.set(-ROOM.W/2, wallY, 0);
  left.rotation.y = -Math.PI/2;
  left.material = unlit("#242424");

  // PRAV√Å stƒõna
  const right = BABYLON.MeshBuilder.CreatePlane("rightWall", {
    width: ROOM.D + OVER,
    height: WALL_H,
    sideOrientation: BABYLON.Mesh.FRONTSIDE
  }, scene);
  right.position.set(ROOM.W/2, wallY, 0);
  right.rotation.y = Math.PI/2;
  right.material = unlit("#242424");

  // ≈Ω√ÅDN√ù strop ‚Äì naho≈ôe je otev≈ôen√© ‚Äûokno‚Äú do oblohy
}


function buildLED() {
  const n = new BABYLON.TransformNode("led", scene);
  const t = 0.02, inw = 0.1;

  const xL = -ROOM.W/2 + inw;
  const xR =  ROOM.W/2 - inw;
  const zF =  ROOM.D/2 - inw;
  const zB = -ROOM.D/2 + inw;

  const y0 = 0.04;
  const y1 = ROOM.H - 0.04;

  const mat = new BABYLON.StandardMaterial("ledMat", scene);
  mat.emissiveColor = BABYLON.Color3.FromHexString("#ffbdf6");
  mat.disableLighting = true;

  const seg = (a, b) => {
    const d = BABYLON.Vector3.Distance(a, b);
    const m = BABYLON.MeshBuilder.CreateBox("ledSeg", {
      width: t,
      height: t,
      depth: d
    }, scene);
    m.position = BABYLON.Vector3.Center(a, b);
    m.lookAt(b);
    m.rotation.x += Math.PI;
    m.material = mat;
    m.isPickable = false;
    m.parent = n;
    glow.addIncludedOnlyMesh(m);
  };

  // Horn√≠ i doln√≠ LED obd√©ln√≠k
  [
    [xL,y0,zF, xR,y0,zF], [xR,y0,zF, xR,y0,zB], [xR,y0,zB, xL,y0,zB], [xL,y0,zB, xL,y0,zF],
    [xL,y1,zF, xR,y1,zF], [xR,y1,zF, xR,y1,zB], [xR,y1,zB, xL,y1,zB], [xL,y1,zB, xL,y1,zF]
  ].forEach(([ax,ay,az, bx,by,bz]) => {
    seg(new BABYLON.Vector3(ax, ay, az), new BABYLON.Vector3(bx, by, bz));
  });

  // Vertik√°ln√≠ LED segmenty
  [
    [xL,zF],
    [xR,zF],
    [xR,zB],
    [xL,zB]
  ].forEach(([x,z]) => {
    seg(
      new BABYLON.Vector3(x, y0, z),
      new BABYLON.Vector3(x, y1, z)
    );
  });
}
  /* =========================
     Picking & zoom UX
  ========================= */
  function setupPicking(){
    scene.onPointerObservable.add((pi)=>{
      if (pi.type !== BABYLON.PointerEventTypes.POINTERPICK) return;
      if (!pi.pickInfo?.hit) return;
      const mesh = pi.pickInfo.pickedMesh;
      for(const wall of Object.keys(framesByWall)){
        for(const it of framesByWall[wall]){
          if (mesh === it.placard && it.data.url){ window.open(it.data.url,"_blank","noopener"); return; }
        }
      }
    }, BABYLON.PointerEventTypes.POINTERPICK);
  }

  function zoomToPointer(px, py, {scale=0.55, forceMin=false}={}){
    const pick = scene.pick(px, py);
    if(!pick?.hit) return;
    camera.target = pick.pickedPoint.clone();
    camera.radius = forceMin ? MIN_RADIUS : Math.max(MIN_RADIUS, camera.radius * scale);
  }

  function setupZoomUX(){
    const canvasEl = document.getElementById('renderCanvas');
    canvasEl.addEventListener("dblclick", ()=>{
      zoomToPointer(scene.pointerX, scene.pointerY, {
        scale: camera.radius < 1.2 ? 1.0 : 0.55,
        forceMin: camera.radius < 0.6
      });
    }, { passive:true });

    let lastTap = 0;
    canvasEl.addEventListener("touchend", (e)=>{
      const now = Date.now();
      const dt  = now - lastTap; lastTap = now;
      if (dt > 280) return;

      const t = e.changedTouches && e.changedTouches[0];
      if (!t) return;
      const rect = canvasEl.getBoundingClientRect();
      const x = t.clientX - rect.left;
      const y = t.clientY - rect.top;

      zoomToPointer(x, y, {
        scale: camera.radius < 1.2 ? 1.0 : 0.55,
        forceMin: camera.radius < 0.6
      });
    }, { passive:true });
  }

 /* =========================
   Obr√°zky / videa / textury ‚Äì unified
========================= */

// Glob√°l: v√Ωsledn√© 9:16 (nebo jin√©) rozmƒõry r√°mu se ƒçtou z FRAME_SIZE
// (FRAME_SIZE nastavuje≈° v applyFixedLayout ‚Äì u tebe natvrdo 9:16)
const FRAME_SIZE = { W: 2, H: 2 };   // init; skuteƒçnou v√Ω≈°ku p≈ôep√≠≈°e applyFixedLayout()
let FRAME_BOX_BORDER = 0.08;
let FRAME_COLOR = "#717171";

function makeDT(name, w, h, genMipmaps=true) {
  const dt = new BABYLON.DynamicTexture(
    name,
    { width:w, height:h },
    scene,
    genMipmaps,
    BABYLON.Texture.TRILINEAR_SAMPLINGMODE
  );
  dt.wrapU = dt.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
  dt.hasAlpha = false;
  dt.anisotropicFilteringLevel = MAX_ANISO || 4;
  return dt;
}

/**
 * Vykresl√≠ zdroj (Image/Canvas/Video frame) do canvasu s "cover" nebo "contain" fitem,
 * bez deformace, s centrac√≠.
 * - targetW/H = rozmƒõr c√≠lov√© textury (typicky TEX_SIZE x TEX_SIZE)
 * - frameW/H  = Fyzick√Ω pomƒõr pl√°tna v r√°mu (FRAME_SIZE.W/H)
 */
function fitDrawToCanvas(ctx, bmp, targetW, targetH, frameW, frameH, mode="cover", bg="#000") {
  const targetR = frameW / frameH;     // pomƒõr fyzick√©ho pl√°tna (nap≈ô. 9:16)
  const r       = bmp.width / bmp.height;

  let dw, dh, dx=0, dy=0;
  if (mode === "cover"){
    if (r > targetR){                 // zdroj "≈°ir≈°√≠" ne≈æ c√≠l ‚Üí pln√° v√Ω≈°ka, o≈ô√≠znout do ≈°√≠≈ôky
      dh = targetH;
      dw = Math.round(dh * r);
      dx = Math.round((targetW - dw) / 2);
    } else {                          // zdroj "u≈æ≈°√≠" ne≈æ c√≠l ‚Üí pln√° ≈°√≠≈ôka, o≈ô√≠znout do v√Ω≈°ky
      dw = targetW;
      dh = Math.round(dw / r);
      dy = Math.round((targetH - dh) / 2);
    }
  } else { // "contain"
    if (r > targetR){                 // zdroj "≈°ir≈°√≠" ‚Üí pln√° ≈°√≠≈ôka, doladit v√Ω≈°ku
      dw = targetW;
      dh = Math.round(dw / r);
      dy = Math.round((targetH - dh) / 2);
    } else {
      dh = targetH;
      dw = Math.round(dh * r);
      dx = Math.round((targetW - dw) / 2);
    }
  }

  if (bg){
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,targetW,targetH);
  }
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.drawImage(bmp, 0,0,bmp.width,bmp.height, dx,dy,dw,dh);
}

function drawChecker(ctx, w, h) {
  const tile = 32;
  for (let y = 0; y < h; y += tile) {
    for (let x = 0; x < w; x += tile) {
      const even = ((x / tile) + (y / tile)) % 2 === 0;
      ctx.fillStyle = even ? "#dcdcdc" : "#f4f4f4";
      ctx.fillRect(x, y, tile, tile);
    }
  }
}

/**
 * Obr√°zek ‚Üí DynamicTexture ‚Üí unlit materi√°l na frame
 * - pou≈æ√≠v√° fit "cover" a pomƒõr FRAME_SIZE (portrait 9:16 nebo dle tv√©ho nastaven√≠)
 */
function setImageToFrame(url, targetItem, texSize=TEX_SIZE, fitMode="cover") {
  targetItem.data.src = url;
  const img = new Image();
  if (!/^(\.|\/)/.test(url)) img.crossOrigin = "anonymous";
  img.decoding = "async";
  img.onload = () => {
    const dt  = makeDT("imgDT_"+Math.random(), texSize, texSize, !IS_MOBILE);
    const ctx = dt.getContext();
    fitDrawToCanvas(ctx, img, texSize, texSize, FRAME_SIZE.W, FRAME_SIZE.H, fitMode, "#000");
    dt.update();

    const mat = unlitTex(dt, { doubleSided:false });
    mat.zOffset = -1;
    targetItem.frame.material = mat;
  };
  img.onerror = () => {
    const dt = makeDT("imgErr_"+Math.random(), texSize, texSize, false);
    const ctx = dt.getContext();
    drawChecker(ctx, texSize, texSize);
    dt.update();
    targetItem.frame.material = unlitTex(dt,{doubleSided:false});
  };
  img.src = url;
}

/**
 * Video ‚Üí VideoTexture ‚Üí unlit materi√°l na frame
 * - autoplay funguje na mobilech, pokud je video muted a po gestu u≈æivatele
 */
function setVideoToFrame(url, targetItem, {
  loop=true, muted=true, autoplay=true, texSampling = BABYLON.Texture.TRILINEAR_SAMPLINGMODE
} = {}){
  const vt = new BABYLON.VideoTexture(
    "vidTex_"+Math.random(),
    url,
    scene,
    true,         // generateMipmaps
    false,        // invertY
    texSampling,
    { autoPlay: autoplay, loop: loop, muted: muted }
  );
  try {
    vt.video.muted = !!muted;
    vt.video.loop = !!loop;
    vt.video.playsInline = true;
  } catch(e){ /* ignore */ }

  // Pozn.: VideoTexture se prom√≠t√° p≈ô√≠mo, bez ruƒçn√≠ho "cover" o≈ôezu.
  // Aspect fit ≈ôe≈°√≠ geometrie pl√°tna (FRAME_SIZE) a UV r√°mu (plane).
  const mat = unlitTex(vt, { doubleSided:false });
  mat.zOffset = -1;
  targetItem.frame.material = mat;
  targetItem.videoTex = vt;
}

/**
 * Unified assign: rozhodne podle p≈ô√≠pony, zda je to obr√°zek nebo video.
 * - preferuje d.src; zpƒõtnƒõ kompatibiln√≠ s d.video / d.img
 */
function assignDataAllWalls(data){
  const isVideoUrl = (u) => /\.(mp4|webm|ogg)$/i.test(u || "");
  const isImageUrl = (u) => /\.(png|jpg|jpeg|webp|gif)$/i.test(u || "");

  ["front","back","left","right"].forEach(side=>{
    const items = data[side] || [];
    const arr   = framesByWall[side] || [];
    const n = Math.min(items.length, arr.length);

    for (let i=0;i<n;i++){
      const it = arr[i];
      const d  = items[i] || {};

      const src = d.src || d.video || d.img || "";
      it.data.src   = src;
      it.data.title = d.label || it.data.title || "(bez n√°zvu)";
      it.data.url   = d.href  || it.data.url || "";

      // Cedulka
      drawPlacard(
        it.placard,
        it.data,
        it.rotY,
        it.placard._width  || FRAME_SIZE.W,
        it.placard._height || Math.max(0.22, FRAME_SIZE.H*0.10)
      );

      if (!src) continue;

      if (isVideoUrl(src)) {
        setVideoToFrame(src, it, {
          loop: d.loop !== false,
          muted: d.muted !== false, // autoplay na mobilech chce muted
          autoplay: true
        });
      } else if (isImageUrl(src)) {
        // GIF se vykresl√≠ jako statick√Ω (prvn√≠ frame). Pro animaci pou≈æij MP4/WebM.
        setImageToFrame(src, it, TEX_SIZE, "cover");
      } else {
        // fallback: zkus jako obr√°zek
        setImageToFrame(src, it, TEX_SIZE, "cover");
      }
    }
  });
}

/* ====== R√°m: multi-material se st√≠novan√Ωmi plochami (ponech√°no, jen p≈ôesunuto) ====== */
function makeGradDT(name, w, h, {from="#7a7a7a", to="#555", vertical=true, radial=false}={}){
  const dt = new BABYLON.DynamicTexture(name, {width:w, height:h}, scene, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
  const ctx = dt.getContext();
  ctx.clearRect(0,0,w,h);
  if (radial){
    const cx=w/2, cy=h/2, r=Math.sqrt(cx*cx+cy*cy);
    const g = ctx.createRadialGradient(cx, cy, r*0.15, cx, cy, r);
    g.addColorStop(0, from);
    g.addColorStop(1, to);
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
  } else {
    const g = vertical ? ctx.createLinearGradient(0,0,0,h) : ctx.createLinearGradient(0,0,w,0);
    g.addColorStop(0, from);
    g.addColorStop(1, to);
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
  }
  dt.update();
  dt.wrapU = dt.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
  dt.anisotropicFilteringLevel = MAX_ANISO || 4;
  return dt;
}
function lighten(col, f){ return new BABYLON.Color3(
  Math.min(1, col.r + (1-col.r)*f),
  Math.min(1, col.g + (1-col.g)*f),
  Math.min(1, col.b + (1-col.b)*f)
);}
function darken(col, f){ return new BABYLON.Color3(
  Math.max(0, col.r*(1-f)),
  Math.max(0, col.g*(1-f)),
  Math.max(0, col.b*(1-f))
);}
function makeShadedFrameBoxMultiMat(baseHex = FRAME_COLOR){
  const c = BABYLON.Color3.FromHexString(baseHex);
  const topLight    = lighten(c, 0.20).toHexString();
  const bottomDark  = darken(c,  0.25).toHexString();
  const sideMidTop  = lighten(c, 0.08).toHexString();
  const sideMidBot  = darken(c,  0.12).toHexString();
  const frontTop    = lighten(c, 0.12).toHexString();
  const frontBot    = darken(c,  0.18).toHexString();
  const backCol     = darken(c,  0.10).toHexString();

  const W=256,H=256;
  const dtFront = makeGradDT("frm_front",  W,H, {from:frontTop, to:frontBot, vertical:true});
  const dtBack  = makeGradDT("frm_back",   W,H, {from:backCol,  to:backCol,  vertical:true});
  const dtRight = makeGradDT("frm_right",  W,H, {from:sideMidTop,to:sideMidBot,vertical:true});
  const dtLeft  = makeGradDT("frm_left",   W,H, {from:sideMidTop,to:sideMidBot,vertical:true});
  const dtTop   = makeGradDT("frm_top",    W,H, {from:topLight,  to:topLight,  vertical:true});
  const dtBottom= makeGradDT("frm_bottom", W,H, {from:bottomDark,to:bottomDark,vertical:true});

  const mk = (name, dt)=>{
    const m = new BABYLON.StandardMaterial(name, scene);
    m.disableLighting = true;
    m.diffuseTexture  = dt; m.emissiveTexture = dt;
    m.specularColor   = new BABYLON.Color3(0,0,0);
    m.backFaceCulling = false;
    m.diffuseTexture.updateSamplingMode(BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
    return m;
  };
  const mats = [ mk("m_front",dtFront), mk("m_back",dtBack), mk("m_right",dtRight), mk("m_left",dtLeft), mk("m_top",dtTop), mk("m_bottom",dtBottom) ];
  const mm = new BABYLON.MultiMaterial("frameBoxMM", scene);
  mats.forEach(m => mm.subMaterials.push(m));
  return mm;
}
   
// ====== MARQUEE (bƒõ≈æ√≠c√≠ text po stƒõn√°ch) ====================================

const MARQUEE = {
  meshes: [],    // plane meshe po stƒõn√°ch
  textures: [],  // DynamicTexture pro ka≈ædou stƒõnu
  speed: 0.015,  // rychlost posunu doleva (uOffset za sekundu)
  color: "#ff2838", // sytƒõ ƒçerven√°
  bandHeight: 0.35, // v√Ω≈°ka p√°su v metrech (jemnƒõ dolad√≠≈°)
  marginX: 0.12,    // odsazen√≠ od roh≈Ø stƒõn (aby nelezlo do roh≈Ø)
  zEps: 0.02,       // jak ‚Äûbl√≠zko‚Äú ke stƒõnƒõ
  fontPx: 120,      // velikost fontu v px na textu≈ôe (pro Doto 700)
  msg: "WELCOME TO THE PHASER STORE ‚Äî FUTURE VISUALS ¬∑ SOUND ¬∑ MOTION ‚Äî ",
  // st≈ô√≠d√°n√≠ s n√°zvem tracku
  alternateWithTrack: true,
  alternateEveryMs: 8000,  // po kolika ms p≈ôepnout welcome <-> track
  _altTimer: 0,
  _mode: 0  // 0 = welcome, 1 = track
};

// Poƒçkej na font ‚ÄûDoto‚Äú, a≈• je kresba ostr√°
async function loadDotoFontOnce(){
  try{
    await document.fonts?.load?.('700 16px "Doto"');
  }catch(e){}
}

function makeMarqueeDT(message, texW=2048, texH=256){
  const dt  = new BABYLON.DynamicTexture("marqueeDT_"+Math.random(), {width:texW, height:texH}, scene, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
  const ctx = dt.getContext();

  // pozad√≠ ‚Äì ƒçern√©, ale nech√°me text ‚Äûsv√≠tit‚Äú p≈ôes emissive
  ctx.clearRect(0,0,texW,texH);
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,texW,texH);

  // text ‚Äì Doto 700, horizont√°ln√≠ opakov√°n√≠
  const fsize = MARQUEE.fontPx; // nap≈ô. 120 px
  ctx.font = `700 ${fsize}px "Doto", system-ui`;
  ctx.fillStyle = MARQUEE.color;
  ctx.textBaseline = "middle";

  // Spoƒçti ≈°√≠≈ôku zpr√°vy a kolikr√°t j√≠ ‚Äûvysypeme‚Äú do ≈°√≠≈ôky
  const gap = Math.round(fsize * 0.75); // mezera mezi opakov√°n√≠mi
  const msgW = Math.ceil(ctx.measureText(message).width);
  const tileW = msgW + gap;

  const y = Math.round(texH/2) + Math.round(fsize*0.08); // jemn√° optick√° korekce baseline
  // Nakresli 2‚Äì3x p≈ôes celou ≈°√≠≈ôku, a≈• m√°me spojiteln√Ω pattern (WRAP)
  // Zaƒçneme z√°pornƒõ, aby byl ‚Äûseamless‚Äú wrap p≈ôi posunu uOffsetem
  let x = -tileW;
  while (x < texW + tileW){
    ctx.fillText(message, x, y);
    x += tileW;
  }

  dt.update();
  // opakov√°n√≠ po U (Wrap), aby uOffset kontinu√°lnƒõ ‚Äûot√°ƒçel‚Äú
  dt.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;
  dt.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
  dt.anisotropicFilteringLevel = MAX_ANISO || 4;
  return dt;
}

function makeMarqueeMat(dt){
  const m = new BABYLON.StandardMaterial("marqueeMat_"+Math.random(), scene);
  m.disableLighting   = true;
  m.backFaceCulling   = false;
  m.diffuseTexture    = dt;         // difuzn√≠ pro barevnost
  m.emissiveTexture   = dt;         // ‚Äûsv√≠t√≠‚Äú ‚Äì ƒçist√Ω look bez svƒõtel
  m.specularColor     = new BABYLON.Color3(0,0,0);
  return m;
}

async function buildMarqueeBands(){
  await loadDotoFontOnce();

  // Y pozice p√°su: tƒõsnƒõ nad topem r√°m≈Ø (horn√≠ hrana r√°m≈Ø) + mal√Ω odstup
  // Kotva na horn√≠ LED (st√°l√° v√Ω≈°ka bez ohledu na 9:16)
const LED_TOP_Y = ROOM.H - 0.04;

// V√Ω≈°ka p√°su a jeho svisl√© um√≠stƒõn√≠ (trochu pod LED)
const h = MARQUEE.bandHeight;       // viz MARQUEE n√≠≈æe
const y = LED_TOP_Y - 0.70;        

  // 4 stƒõny: ≈°√≠≈ôky dle stƒõn (X/Z) a rotace do interi√©ru
  const items = [
    { name:"front", w: ROOM.W - 2*MARQUEE.marginX, h, pos: new BABYLON.Vector3(0, y,  ROOM.D/2 - MARQUEE.zEps), rotY: Math.PI },
    { name:"back",  w: ROOM.W - 2*MARQUEE.marginX, h, pos: new BABYLON.Vector3(0, y, -ROOM.D/2 + MARQUEE.zEps), rotY: 0 },
    { name:"left",  w: ROOM.D - 2*MARQUEE.marginX, h, pos: new BABYLON.Vector3(-ROOM.W/2 + MARQUEE.zEps, y, 0),  rotY: -Math.PI/2 },
    { name:"right", w: ROOM.D - 2*MARQUEE.marginX, h, pos: new BABYLON.Vector3( ROOM.W/2 - MARQUEE.zEps, y, 0),  rotY:  Math.PI/2 }
  ];

  // p≈ôiprav texturu pro aktu√°ln√≠ zpr√°vu
  const baseMsg = MARQUEE.msg;
  const dt = makeMarqueeDT(baseMsg, 2048, 256);

  MARQUEE.meshes.length = 0;
  MARQUEE.textures.length = 0;

  for (const it of items){
    const p = BABYLON.MeshBuilder.CreatePlane("marquee_"+it.name, {
      width: it.w, height: it.h, sideOrientation: BABYLON.Mesh.FRONTSIDE
    }, scene);
    p.position.copyFrom(it.pos);
    p.rotation.y = it.rotY;
    p.isPickable = false;

    const mat = makeMarqueeMat(dt);
    p.material = mat;

    // Ka≈æd√° stƒõna dostane vlastn√≠ instanci textury, a≈• m≈Ø≈æeme posouvat nez√°visle
    const cloneDT = dt.clone(); // klon (sd√≠l√≠ image, m√° vlastn√≠ transform/offset)
    mat.diffuseTexture  = cloneDT;
    mat.emissiveTexture = cloneDT;

    // Jemn√Ω ‚Äûsvit‚Äú ‚Äì nech√°me glow, ale a≈• to nep≈ôebije
    try { glow?.addIncludedOnlyMesh?.(p); } catch(e){}
    MARQUEE.meshes.push(p);
    MARQUEE.textures.push(cloneDT);
  }
}

// Zmƒõna textu v bƒõhu ‚Äì p≈ôekresl√≠ DynamicTexture v≈°ech stƒõn
async function setMarqueeText(newMsg){
  await loadDotoFontOnce();
  const baseMsg = (newMsg || "").trim();
  if (!baseMsg) return;

  // vygeneruj novou z√°kladn√≠ DT (seamless) a p≈ôepi≈° v≈°em
  const dtNewBase = makeMarqueeDT(baseMsg, 2048, 256);
  MARQUEE.textures.forEach((oldDT, i)=>{
    // z bezpeƒçnostn√≠ch d≈Øvod≈Ø nov√Ω klon pro ka≈ædou stƒõnu
    const clone = dtNewBase.clone();
    const mat = MARQUEE.meshes[i]?.material;
    if (mat) {
      mat.diffuseTexture  = clone;
      mat.emissiveTexture = clone;
    }
    MARQUEE.textures[i] = clone;
  });
}

// (Voliteln√©) p≈ôepnout text podle aktu√°ln√≠ho tracku z SC
function setMarqueeFromTrack(trackTitle){
  const t = (trackTitle || "").trim();
  if (!t) return;
  const msg = `NOW PLAYING: ${t} ‚Äî `;
  setMarqueeText(msg);
}

// Spus≈• animaci ‚Äì v render loopu posouv√°me uOffset
function tickMarquee(deltaSec){
  if (!MARQUEE.textures?.length) return;
  const du = MARQUEE.speed * deltaSec;
  for (const tex of MARQUEE.textures){
    // uOffset jde doleva
    tex.uOffset = (tex.uOffset - du) % 1;
  }
}

// (Voliteln√©) st≈ô√≠d√°n√≠ welcome <-> ‚Äûnow playing‚Äú
function alternateMarqueeUpdate(deltaMs){
  if (!MARQUEE.alternateWithTrack) return;
  MARQUEE._altTimer += deltaMs;
  if (MARQUEE._altTimer < MARQUEE.alternateEveryMs) return;
  MARQUEE._altTimer = 0;

  if (MARQUEE._mode === 0){
    // p≈ôepni na track
    try{
      if (window.scReady && window.scWidget){
        window.scWidget.getCurrentSound((s)=>{
          const title = s?.title || "";
          if (title) { setMarqueeFromTrack(title); MARQUEE._mode = 1; }
        });
      }
    }catch(e){}
  } else {
    // zpƒõt na welcome
    setMarqueeText(MARQUEE.msg);
    MARQUEE._mode = 0;
  }
}

  // Cedulka (plaketa)
  function drawPlacard(plac, data, rotY, planeW, planeH){
    const texWFull = TEX_SIZE;
    const texWTarget = IS_MOBILE ? Math.max(256, Math.min(1024, Math.round(texWFull * 0.5))) : texWFull;
    const texW = nearestPOT(texWTarget, IS_MOBILE ? 1024 : 2048);
    const texH = nearestPOT(Math.max(64, Math.round(texW * (planeH / planeW))), texW);

    const dt = makeDT("pl", texW, texH, !IS_MOBILE);
    const c = dt.getContext();
    c.fillStyle = "#6b6b6b";
    c.fillRect(0,0,texW,texH);

    const pad = Math.round(texH * 0.12);
    const maxW = texW - pad*2;

    c.fillStyle = "#ffffff";
    c.textAlign = "center";
    c.textBaseline = "top";
    const lineH = Math.round(texH * 0.34);
    const fontSize = Math.max(18, Math.round(lineH * 0.78));
    c.font = `600 ${fontSize}px Poppins, system-ui`;

    const text = (data.title || "(bez n√°zvu)").trim();
    const words = text.split(/\s+/);
    const lines = [];
    let buf = "";
    for (let w of words){
      const test = buf ? (buf + " " + w) : w;
      if (c.measureText(test).width <= maxW) buf = test;
      else { if (buf) lines.push(buf); buf = w; }
    }
    if (buf) lines.push(buf);

    const maxLines = 2;
    if (lines.length > maxLines){
      const keep = lines.slice(0, maxLines);
      let last = keep[maxLines-1];
      while (c.measureText(last + "‚Ä¶").width > maxW && last.length>0) last = last.slice(0,-1);
      keep[maxLines-1] = last + "‚Ä¶";
      lines.length = 0; Array.prototype.push.apply(lines, keep);
    }

    const blockH = lines.length * lineH;
    const startY = Math.max(pad, Math.round((texH - blockH)/2));
    lines.forEach((ln, i)=> c.fillText(ln, texW / 2, startY + i*lineH + Math.round(lineH*0.1)));

    dt.update();
    const mat = unlitTex(dt, { doubleSided:false });
    mat.zOffset = -2; // anti z-fighting
    plac.material = mat;
  }

  function normalOffset(rotY, dist){
    const nx = Math.sin(rotY) * dist;
    const nz = Math.cos(rotY) * dist;
    return new BABYLON.Vector3(nx, 0, nz);
  }

  function addFrame(pos, rotY=0, wall='front'){
    const box = BABYLON.MeshBuilder.CreateBox("frameBox", {
      width: FRAME_SIZE.W + FRAME_BOX_BORDER,
      height: FRAME_SIZE.H + FRAME_BOX_BORDER,
      depth: 0.06
    }, scene);
    box.position = pos.add(normalOffset(rotY, 0.0));
    box.rotation.y = rotY;
    box.isPickable = true;

    // Submeshe + MultiMaterial
    box.subMeshes = [];
    const indices = box.getIndices();
    const verticesCount = box.getTotalVertices();
    let idx = 0;
    const perFace = indices.length / 6;
    for (let f = 0; f < 6; f++){
      new BABYLON.SubMesh(f, 0, verticesCount, idx, perFace, box);
      idx += perFace;
    }
    box.material = makeShadedFrameBoxMultiMat(FRAME_COLOR);

    // P≈ôedn√≠ obrazov√° plocha
    const f = BABYLON.MeshBuilder.CreatePlane("frame", {
      width: FRAME_SIZE.W,
      height: FRAME_SIZE.H,
      sideOrientation: BABYLON.Mesh.FRONTSIDE
    }, scene);
    f.position = pos.add(normalOffset(rotY, 0.04));
    f.rotation.y = rotY + Math.PI;
    f.isPickable = true;

    const dt = makeDT("ph_img", TEX_SIZE, TEX_SIZE, true);
    const ctx = dt.getContext(); drawChecker(ctx, TEX_SIZE, TEX_SIZE); dt.update();
    const fMat = unlitTex(dt,{doubleSided:false});
    fMat.zOffset = -1;
    f.material  = fMat;

    // Cedulka
    const placW = FRAME_SIZE.W;
    const placH = Math.max(0.22, FRAME_SIZE.H * 0.10);
    const plac = BABYLON.MeshBuilder.CreatePlane("plac", {
      width: placW, height: placH, sideOrientation: BABYLON.Mesh.FRONTSIDE
    }, scene);
    plac.position = pos.add(new BABYLON.Vector3(0, -FRAME_SIZE.H*0.83, 0)).add(normalOffset(rotY, 0.03));
    plac.rotation.y = rotY + Math.PI;
    plac.isPickable = true;

    // Kompenzace ‚Äî a≈• se cedulka v√Ωslednƒõ posune p≈ôesnƒõ o Œî (ne ~1.33√óŒî)
if (typeof FRAME_DELTA_H === "number" && FRAME_DELTA_H !== 0) {
  plac.position.y += FRAME_DELTA_H * (1/3);
}

    const data = { title: "(bez n√°zvu)", url: "", src: "" };
    drawPlacard(plac, data, rotY, placW, placH);

    return { frame:f, box, placard:plac, data, wall, rotY, pos };
  }

      /* =========================
     LOGO ‚Äì inline SVG (ostr√Ω + glow) na zadn√≠ i p≈ôedn√≠ stƒõnu
  ========================= */
  const GALLERY_LOGO_SVG = `
<svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 941.43 272.86" preserveAspectRatio="xMidYMid meet">
  <defs><style>.cls-1{fill:#daff3e;}</style></defs>
  <g>
    <path class="cls-1" d="M317.06,103.94h-76.71c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h76.71c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
    <path class="cls-1" d="M299.75,179.35c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l17.31-75.4c.46-2,2.46-3.25,4.45-2.79,2,.46,3.25,2.45,2.79,4.45l-17.31,75.4c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M222.8,180.12c-.28,0-.56-.03-.84-.1-2-.46-3.25-2.45-2.79-4.45l27.14-117.91c.46-2,2.45-3.25,4.46-2.79 2,.46 3.25,2.46 2.79,4.46l-27.14,117.91c-.4,1.72-1.93,2.88-3.62,2.88Z"/>
    <path class="cls-1" d="M439.3,179.34h-139.39c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h136.43l15.6-67.97h-70.53c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h75.2c1.13,0,2.2.52,2.91,1.4.71.89.97,2.04.72,3.15l-17.31,75.4c-.39,1.69-1.89,2.88-3.62,2.88Z"/>
    <path class="cls-1" d="M785.01,179.34c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l17.31-75.4c.39-1.69,1.89-2.88,3.62-2.88h76.96c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72h-74l-16.65,72.52c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M211.85,180.13l-170.7-.27c-2.05,0-3.71-1.67-3.71-3.72,0-2.05,1.67-3.71,3.72-3.71l170.7.27c2.05,0,3.71,1.67,3.71,3.72,0,2.05-1.67,3.71-3.72,3.71Z"/>
    <path class="cls-1" d="M72.27,221.31c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l26.94-117.36c.46-2,2.46-3.25,4.45-2.79,2,.46,3.25,2.45,2.79,4.45l-26.94,117.36c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M784.97,179.34h-141.2c-1.13,0-2.2-.52-2.91-1.4-.71-.89-.97-2.04-.72-3.15l17.31-75.4c.39-1.69,1.89-2.88,3.62-2.88h76.41c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72h-73.45l-15.6,67.97h136.53c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
    <path class="cls-1" d="M158.76,180.12c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l16.44-71.63h-72.37c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h77.03c1.13,0,2.2.52,2.91,1.4.71.89.97,2.04.71,3.15l-17.49,76.18c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M222.74,180.13l-182.02-.27c-2.05,0-3.71-1.67-3.71-3.72,0-2.05,1.67-3.71,3.72-3.71l182.02.27c2.05,0,3.71,1.67,3.71,3.72,0,2.05-1.67,3.71-3.72,3.71Z"/>
    <path class="cls-1" d="M602.74,212.29c-.55,0-1.09-.12-1.61-.37-.76-.36-1.35-.96-1.71-1.68l-103.95-136.78-129.09,105.46c-1.59,1.3-3.93,1.06-5.23-.53-1.3-1.59-1.06-3.93.53-5.23l131.89-107.74c.39-.36.86-.64,1.38-.81,1.5-.48,3.14.02,4.1,1.28l104.39,137.36 131.99-105.98c1.6-1.29,3.94-1.03,5.22.57 1.28,1.6 1.03,3.94-.57,5.22l-135.02,108.4c-.67.54-1.5.82-2.33.82Z"/>
  </g>
  <g>
    <path class="cls-1" d="M596.11,104.5h-75.2c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h75.2c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
    <path class="cls-1" d="M577.73,179.9h-74.12c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h74.12c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
  </g>
</svg>`;
  const LOGO_ASPECT = 941.43 / 202.86;
  const LOGO_SCALE = 0.30;
  const FRONT_BACK_OFFSET = 0.25;
  const LOGO_HEIGHT_M = 6.30;
  const GLOW_BLUR_PX = 18;

  function buildGalleryLogo(){
    const img = new Image();
    img.src = "data:image/svg+xml;utf8," + encodeURIComponent(GALLERY_LOGO_SVG);
    img.onload = () => {
      const SIZE = 1024;
      const dt  = new BABYLON.DynamicTexture("logoDT",{width:SIZE,height:SIZE},scene,true);
      const ctx = dt.getContext();
      const maxW = SIZE * 0.92;
      const w = maxW, h = Math.round(maxW / LOGO_ASPECT);
      const x = Math.round((SIZE - w)/2), y = Math.round((SIZE - h)/2);
      ctx.clearRect(0,0,SIZE,SIZE); ctx.drawImage(img, x, y, w, h); dt.update();

      const glowDT = new BABYLON.DynamicTexture("logoGlowDT",{width:SIZE,height:SIZE},scene,true);
      const gc = glowDT.getContext();
      gc.clearRect(0,0,SIZE,SIZE); gc.filter = `blur(${GLOW_BLUR_PX}px)`; gc.drawImage(img, x, y, w, h); glowDT.update();

      const sharpMat = new BABYLON.StandardMaterial("logoSharpMat", scene);
      sharpMat.disableLighting = true; sharpMat.diffuseTexture  = dt; sharpMat.opacityTexture  = dt;
      sharpMat.emissiveColor   = new BABYLON.Color3(1,1,1); sharpMat.backFaceCulling = false;

      const glowMat = new BABYLON.StandardMaterial("logoGlowMat", scene);
      glowMat.disableLighting  = true; glowMat.emissiveTexture  = glowDT; glowMat.opacityTexture   = glowDT;
      glowMat.emissiveColor    = new BABYLON.Color3(1,1,1); glowMat.backFaceCulling  = false;

      const logoW = ROOM.W * LOGO_SCALE;
      const logoH = LOGO_HEIGHT_M;
      const LED_TOP_Y = ROOM.H - 0.04;
const yPos = LED_TOP_Y - 0.15;   // logo cca 15 cm pod LED (dolad√≠≈° -0.10 a≈æ -0.25)

      function placeLogo(z, rotY, idx){
        const g = BABYLON.MeshBuilder.CreatePlane(`logoGlow_${idx}`, { width:logoW, height:logoH }, scene);
        g.position.set(0, yPos, z - Math.sign(z)*0.005); g.rotation.y = rotY; g.material = glowMat; glow.addIncludedOnlyMesh(g);

        const s = BABYLON.MeshBuilder.CreatePlane(`logoSharp_${idx}`, { width:logoW, height:logoH }, scene);
        s.position.set(0, yPos, z + Math.sign(z)*0.005); s.rotation.y = rotY; s.material = sharpMat;
      }
      // zadn√≠ + p≈ôedn√≠ stƒõna
      placeLogo(-ROOM.D/2 + FRONT_BACK_OFFSET, Math.PI, 0);
      placeLogo( ROOM.D/2 - FRONT_BACK_OFFSET, 0,       1);
      hint("Logo (inline SVG) zobrazeno ‚úî  (glow aktivn√≠)");
    };
    img.onerror = (e) => { console.error("Logo SVG ne≈°lo dek√≥dovat.", e); hint("Chyba: logo SVG ne≈°lo dek√≥dovat."); };
  }


  /* =========================
   Gener√°tor r√°m≈Ø + data (pevn√©)
========================= */
const framesByWall = { back: [], front: [], left: [], right: [] };

const FIXED_LAYOUT = {
  safeWall: 1.0, cornerSafe: 1.0,
  frame: { width: 2.2, height: 2.2, border: 0.08, color: "#717171" },
  counts: { front: 4, back: 4, left: 7, right: 7 }
};

// ‚úÖ ZACHOV√ÅNO: DATA se "img" (a volitelnƒõ "href")
const DATA = {
  front: [
    { img: "./assets/one.jpg",   label: "Produkt A", href: "https://everpress.com/the-future-phaser-collection2" },
    { img: "./assets/two.jpg",   label: "Produkt B", href: "https://example.com/b" },
    { img: "./assets/three.jpg", label: "Produkt C", href: "https://example.com/c" },
    { img: "./assets/one.jpg",   label: "Produkt D", href: "https://example.com/d" }
  ],
  back: [
    { img: "./assets/one.jpg",   label: "Back A", href: "https://example.com/a" },
    { img: "./assets/two.jpg",   label: "Back B", href: "https://example.com/b" },
    { img: "./assets/three.jpg", label: "Back C", href: "https://example.com/c" },
    { img: "./assets/one.jpg",   label: "Back D", href: "https://example.com/d" }
  ],
  left: [
    { img: "./assets/one.jpg",   label: "Lev√° 1", href: "https://example.com/left-1" },
    { img: "./assets/two.jpg",   label: "Lev√° 2", href: "https://example.com/left-2" },
    { img: "./assets/three.jpg", label: "Lev√° 3", href: "https://example.com/left-3" },
    { img: "./assets/one.jpg",   label: "Lev√° 4", href: "https://example.com/left-4" },
    { img: "./assets/two.jpg",   label: "Lev√° 5", href: "https://example.com/left-5" },
    { img: "./assets/three.jpg", label: "Lev√° 6", href: "https://example.com/left-6" },
    { img: "./assets/one.jpg",   label: "Lev√° 7", href: "https://example.com/left-7" }
  ],
  right: [
    { img: "./assets/two.jpg",   label: "Prav√° 1", href: "https://example.com/right-1" },
    { img: "./assets/three.jpg", label: "Prav√° 2", href: "https://example.com/right-2" },
    { img: "./assets/one.jpg",   label: "Prav√° 3", href: "https://example.com/right-3" },
    { img: "./assets/two.jpg",   label: "Prav√° 4", href: "https://example.com/right-4" },
    { img: "./assets/three.jpg", label: "Prav√° 5", href: "https://example.com/right-5" },
    { img: "./assets/one.jpg",   label: "Prav√° 6", href: "https://example.com/right-6" },
    { img: "./assets/two.jpg",   label: "Prav√° 7", href: "https://example.com/right-7" }
  ]
};

function distributeCenters(min, max, count, frameW){
  if (count <= 1) return [ (min+max)/2 ];
  const span = max - min;
  const totalFramesWidth = count * frameW;
  let gap = (span - totalFramesWidth) / (count - 1);
  const MIN_GAP = 0.05;
  if (gap < MIN_GAP) gap = Math.max(gap, MIN_GAP);
  const centers = [];
  let x = min + frameW/2;
  for (let i = 0; i < count; i++) { centers.push(x); x += frameW + gap; }
  if (centers[centers.length-1] > max - frameW/2 + 1e-6) {
    const step = (max - min) / (count - 1);
    centers.length = 0;
    for (let i=0;i<count;i++) centers.push(min + i*step);
  }
  return centers;
}

function createFixedFramesForWall(wall, count, centerY, safeWall, cornerSafe){
  const rotY =
    wall==='front' ? Math.PI :
    wall==='back'  ? 0 :
    wall==='left'  ? Math.PI/2 :
    wall==='right' ? -Math.PI/2 : 0;

  const axisX  = (wall==='front'||wall==='back');
  const length = axisX ? ROOM.W : ROOM.D;

  const min = -length/2 + safeWall + cornerSafe;
  const max =  length/2 - safeWall - cornerSafe;

  // ‚ö†Ô∏è Pot≈ôebujeme m√≠t V≈ΩDY definovan√© FRAME_SIZE.W (applyFixedLayout to dƒõl√°)
  const frameW = (typeof FRAME_SIZE?.W === "number" && FRAME_SIZE.W > 0) ? FRAME_SIZE.W : (FIXED_LAYOUT.frame.width || 2.2);
  const centers = distributeCenters(min, max, count, frameW);

  // cleanup star√Ωch mesh≈Ø
  framesByWall[wall].forEach(it => { it.frame.dispose(); it.box.dispose(); it.placard.dispose(); });
  framesByWall[wall] = [];

  centers.forEach(val=>{
    const pos = axisX
      ? new BABYLON.Vector3(val, centerY, (wall==='front' ? ROOM.D/2 - 0.03 : -ROOM.D/2 + 0.03))
      : new BABYLON.Vector3((wall==='right' ? ROOM.W/2 - 0.03 : -ROOM.W/2 + 0.03), centerY, val);
    const it = addFrame(pos, rotY, wall);
    framesByWall[wall].push(it);
  });
}

/* =========================
   M√âDIA ‚Üí r√°m (jist√Ω loader pro IMG/VIDEO)
========================= */
(function ensureMediaAssignment(){
  // 1) mal√Ω cover-fit fallback, pokud by nebyl k dispozici "setImageToFrame"
  function _fallbackImageToFrame(url, targetItem, texSize=TEX_SIZE){
    const img = new Image();
    const local = url.startsWith("./") || url.startsWith("/") || url.startsWith("../");
    if (!local) img.crossOrigin = "anonymous";
    img.decoding = "async";
    img.onload = () => {
      const dt = new BABYLON.DynamicTexture("imgDT_"+Math.random(), { width:texSize, height:texSize }, scene, !IS_MOBILE, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
      const ctx = dt.getContext();
      // cover podle pomƒõru r√°mu (FRAME_SIZE.W/H)
      const frameW = FRAME_SIZE?.W || FIXED_LAYOUT.frame.width;
      const frameH = FRAME_SIZE?.H || FIXED_LAYOUT.frame.height;
      const targetR = frameW / frameH;
      const r = img.width / img.height;
      let dw, dh, dx=0, dy=0;
      if (r > targetR){ dh = texSize; dw = Math.round(dh * r); dx = Math.round((texSize - dw)/2); }
      else            { dw = texSize; dh = Math.round(dw / r); dy = Math.round((texSize - dh)/2); }
      ctx.fillStyle = "#000"; ctx.fillRect(0,0,texSize,texSize);
      ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = "high";
      ctx.drawImage(img,0,0,img.width,img.height, dx,dy,dw,dh);
      dt.update();
      const mat = unlitTex(dt,{doubleSided:false}); mat.zOffset = -1;
      targetItem.frame.material = mat;
      console.log("[IMG OK]", url, img.width + "x" + img.height);
    };
    img.onerror = () => {
      const dt = new BABYLON.DynamicTexture("imgERR_"+Math.random(), { width:texSize, height:texSize }, scene, false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
      const ctx = dt.getContext();
      // checker fallback
      const tile=32; for (let y=0;y<texSize;y+=tile){ for (let x=0;x<texSize;x+=tile){
        ctx.fillStyle = (((x/tile)+(y/tile))%2===0) ? "#dcdcdc" : "#f4f4f4"; ctx.fillRect(x,y,tile,tile);
      }} dt.update();
      targetItem.frame.material = unlitTex(dt,{doubleSided:false});
      console.warn("[IMG ERR]", url);
    };
    img.src = url;
  }

  // 2) Mal√Ω helper na video, pokud bys nemƒõl definovan√Ω "setVideoToFrame"
  function _fallbackVideoToFrame(url, targetItem, { loop=true, muted=true, autoplay=true } = {}){
    const vt = new BABYLON.VideoTexture("vidTex_"+Math.random(), url, scene, true, false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, { autoPlay: autoplay, loop: loop, muted: muted });
    try{ vt.video.muted = !!muted; vt.video.loop = !!loop; vt.video.playsInline = true; }catch(e){}
    const mat = unlitTex(vt, { doubleSided:false }); mat.zOffset = -1;
    targetItem.frame.material = mat;
    targetItem.videoTex = vt;
    console.log("[VIDEO SET]", url);
  }

  // 3) fin√°ln√≠ p≈ôi≈ôazen√≠ m√©di√≠: d.src | d.video | d.img
  window.assignDataAllWalls = function(data){
    const isVideoUrl = (u) => /\.(mp4|webm|ogg)$/i.test(u||"");
    const isImageUrl = (u) => /\.(png|jpg|jpeg|webp|gif)$/i.test(u||"");

    ["front","back","left","right"].forEach(side=>{
      const items = data[side] || [];
      const arr   = framesByWall[side] || [];
      const n = Math.min(items.length, arr.length);

      for (let i=0;i<n;i++){
        const it = arr[i];
        const d  = items[i] || {};
        const src = d.src || d.video || d.img || "";   // ‚úÖ podporujeme "img" (tv√© DATA), ale i "src"/"video"

        it.data.src   = src;
        it.data.title = d.label || it.data.title || "(bez n√°zvu)";
        it.data.url   = d.href  || it.data.url || "";

        // Plaketa
        drawPlacard(
          it.placard,
          it.data,
          it.rotY,
          it.placard._width  || (FRAME_SIZE?.W || FIXED_LAYOUT.frame.width),
          it.placard._height || Math.max(0.22, (FRAME_SIZE?.H || FIXED_LAYOUT.frame.height) * 0.10)
        );

        if (!src){ console.warn("[assign] pr√°zdn√Ω src", side, i); continue; }
        console.log("[assign]", side, i, "src=", src);

        // ‚öôÔ∏è preferuj tvoje existuj√≠c√≠ helpery, jinak fallback
        if (isVideoUrl(src)) {
          if (typeof setVideoToFrame === "function") setVideoToFrame(src, it, { loop: d.loop !== false, muted: d.muted !== false, autoplay: true });
          else _fallbackVideoToFrame(src, it, { loop: d.loop !== false, muted: d.muted !== false, autoplay: true });
        } else if (isImageUrl(src)) {
          if (typeof setImageToFrame === "function") setImageToFrame(src, it, TEX_SIZE, "cover");
          else _fallbackImageToFrame(src, it, TEX_SIZE);
        } else {
          // nezn√°m√° p≈ô√≠pona ‚Äî zkus jako obr√°zek
          if (typeof setImageToFrame === "function") setImageToFrame(src, it, TEX_SIZE, "cover");
          else _fallbackImageToFrame(src, it, TEX_SIZE);
        }
      }
    });

    console.log("assignDataAllWalls done");
  };
})();
  // Glob√°ly pro posun cedulek (dej je klidnƒõ nad funkci, jednou pro cel√© JS)
let FRAME_BASE_H  = 2.2;  // p≈Øvodn√≠ v√Ω≈°ka z FIXED_LAYOUT (kv≈Øli v√Ωpoƒçtu Œî)
let FRAME_DELTA_H = 0;    // o kolik jsme r√°m prodlou≈æili

async function applyFixedLayout() {
  const YCENTER = ROOM.H * 0.55;

  const safeWall   = FIXED_LAYOUT.safeWall;
  const cornerSafe = FIXED_LAYOUT.cornerSafe;

  const baseW = FIXED_LAYOUT.frame.width;   // 2.2
  const baseH = FIXED_LAYOUT.frame.height;  // 2.2 (p≈Øvodnƒõ ƒçtverec)
  FRAME_BASE_H = baseH;

  // NATVRDO portrait 9:16 ‚Äî dr≈æ√≠me ≈°√≠≈ôku, dopoƒç√≠t√°me v√Ω≈°ku
  const newW = baseW;
  const newH = baseW * (16/9);

  FRAME_SIZE.W     = newW;
  FRAME_SIZE.H     = newH;
  FRAME_BOX_BORDER = FIXED_LAYOUT.frame.border;
  FRAME_COLOR      = FIXED_LAYOUT.frame.color;

  // Œî = rozd√≠l nov√© v√Ω≈°ky proti p≈Øvodn√≠
  FRAME_DELTA_H = newH - baseH;

  // Ukotven√≠ naho≈ôe: st≈ôed posuneme dol≈Ø o Œî/2 (horn√≠ hrana z≈Østane)
  const centerY = YCENTER - FRAME_DELTA_H/2;

  createFixedFramesForWall('front', FIXED_LAYOUT.counts.front,  centerY, safeWall, cornerSafe);
  createFixedFramesForWall('back',  FIXED_LAYOUT.counts.back,   centerY, safeWall, cornerSafe);
  createFixedFramesForWall('left',  FIXED_LAYOUT.counts.left,   centerY, safeWall, cornerSafe);
  createFixedFramesForWall('right', FIXED_LAYOUT.counts.right,  centerY, safeWall, cornerSafe);

  assignDataAllWalls(DATA);

  console.log("applyFixedLayout 9:16", {W:FRAME_SIZE.W, H:FRAME_SIZE.H, delta:FRAME_DELTA_H});
}

  /* =========================
     SoundCloud player (tenk√Ω bar)
  ========================= */
  const SC_PLAYLIST_URL = "https://soundcloud.com/vertigo01/sets/detroit-techno";
  let scWidget = null, scReady = false, scLoading = false, scDuration = 0;

  function loadScApiOnce(){
    return new Promise((resolve, reject)=>{
      if (window.SC && window.SC.Widget) return resolve();
      const s = document.createElement('script');
      s.src = "https://w.soundcloud.com/player/api.js";
      s.async = true;
      s.onload = ()=> resolve();
      s.onerror = ()=> reject(new Error("SC API failed to load"));
      document.head.appendChild(s);
    });
  }

  function mountScIframeOnce(){
    return new Promise((resolve)=>{
      const host = document.getElementById('scIframeHost');
      let iframe = host.querySelector('iframe');
      if (iframe) return resolve(iframe);

      const url = "https://w.soundcloud.com/player/?"
        + "url=" + encodeURIComponent(SC_PLAYLIST_URL)
        + "&auto_play=false&hide_related=false&show_comments=false"
        + "&show_user=true&show_reposts=false&show_teaser=false&visual=true";

      iframe = document.createElement('iframe');
      iframe.id = "scIframe";
      iframe.title = "SoundCloud Player";
      iframe.allow = "autoplay";
      iframe.setAttribute("scrolling","no");
      iframe.setAttribute("frameborder","no");
      iframe.style.width = "0";
      iframe.style.height= "0";
      iframe.style.border = "0";
      iframe.src = url;

      host.appendChild(iframe);
      resolve(iframe);
    });
  }

  // === Bar helpers ===
  function scUpdateTime(cur, dur){
    const curEl = document.getElementById("scTimeCur");
    const durEl = document.getElementById("scTimeDur");
    if (!curEl || !durEl) return;
    curEl.textContent = fmtTime(cur);
    durEl.textContent = fmtTime(dur);
  }
  function scUpdateThumb(s){
    const t = document.getElementById("scThumb");
    if (!t) return;
    let art = s?.artwork_url || s?.user?.avatar_url || "";
    if (art) art = art.replace("-large.jpg","-t200x200.jpg");
    t.src = art || "";
  }
  function scUpdateTitle(s){
    const el = document.getElementById("scTitle");
    if (!el) return;
    if (!s){ el.textContent = "‚Äì"; return; }
    el.textContent = s.title || "Unknown";
  }
  function scUpdateProgress(rel){
    const fill = document.getElementById("scSeekFill");
    if (!fill) return;
    fill.style.width = (Math.max(0, Math.min(1, rel)) * 100).toFixed(2) + "%";
  }

  function initScWidgetOnce(){
  return new Promise((resolve)=>{
    const iframe = document.getElementById('scIframe');
    if (!iframe || !window.SC || !window.SC.Widget) return resolve(null);
    if (scWidget) return resolve(scWidget);

    scWidget = window.SC.Widget(iframe);

    scWidget.bind(window.SC.Widget.Events.READY, () =>{
      scReady = true;

      const barVol = document.getElementById('barVol');
      const vol = Math.max(0, Math.min(100, +(barVol?.value || 80)));
      scWidget.setVolume(vol);

      scWidget.getCurrentSound((s) => {
        scUpdateTitle(s);
        scUpdateThumb(s);
        // P≈ôepne marquee na NOW PLAYING hned po naƒçten√≠ widgetu (pokud je alternace zapnut√°)
        if (MARQUEE?.alternateWithTrack) setMarqueeFromTrack(s?.title || "");
      });

      scWidget.getDuration((d) => { scDuration = d || 0; scUpdateTime(0, scDuration); });

      scWidget.bind(window.SC.Widget.Events.PLAY, () => {
        scWidget.getCurrentSound((s) => {
          scUpdateTitle(s);
          scUpdateThumb(s);
          // P≈ôepne marquee p≈ôi p≈ôehr√°n√≠/zmƒõnƒõ skladby
          if (MARQUEE?.alternateWithTrack) setMarqueeFromTrack(s?.title || "");
        });
      });

      scWidget.bind(window.SC.Widget.Events.PAUSE, () => {});
      scWidget.bind(window.SC.Widget.Events.PLAY_PROGRESS, (e) => {
        scDuration = Math.max(scDuration, e?.duration || scDuration || 0);
        const cur = e.currentPosition || 0;
        const rel = e.relativePosition || (scDuration ? cur / scDuration : 0);
        scUpdateTime(cur, scDuration);
        scUpdateProgress(rel);
      });

      resolve(scWidget);
    });
  });
}
  /* =========================
     Reset kamery
  ========================= */
  function resetCamera(){
    if (!camera) return;
    camera.target.set(0, ROOM.H*0.48, 0);
    camera.radius = 11.5;
    camera.alpha  = -Math.PI/2;
    camera.beta   =  Math.PI/2.25;
  }

  /* =========================
     Fullscreen API
  ========================= */
  function isFullscreen(){
    return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
  }
  function requestFs(el){
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
    if (req) req.call(el);
  }
  function exitFs(){
    const ex = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
    if (ex) ex.call(document);
  }
  function toggleFullscreen(){
    if (isFullscreen()) exitFs(); else requestFs(document.documentElement);
  }
  function syncFsButton(){
    const btn = document.getElementById('fullscreenIcon');
    if (!btn) return;
    const on = isFullscreen();
    btn.setAttribute('aria-pressed', on ? 'true' : 'false');
    btn.title = on ? 'Ukonƒçit cel√© okno (Esc)' : 'P≈ôepnout cel√© okno';
  }

  // Boot
  createScene();
  (async function boot(){
    await document.fonts?.load?.('400 16px Poppins');
    await document.fonts?.load?.('600 16px Poppins');
    await applyFixedLayout();
        await buildMarqueeBands();
await setMarqueeText(MARQUEE.msg);
    bindBarControls();
    resetCamera();
  })();

  // Render loop + mobiln√≠ auto-quality
  engine.runRenderLoop(()=>{
    if (!scene) return;
        
 const dtMs = engine.getDeltaTime();      // ms od posledn√≠ho frame
  const dtSec = dtMs * 0.001;

    scene.render();
    // ‚¨á‚¨á‚¨á POSUN MARQUEE + st≈ô√≠d√°n√≠ welcome/now playing
  tickMarquee(dtSec);
  alternateMarqueeUpdate(dtMs);
  // ‚¨Ü‚¨Ü‚¨Ü

    if (AutoScale.enabled){
      const now = performance.now();
      AutoScale.accMs += engine.getDeltaTime();
      AutoScale.frames++;

      if (now - AutoScale.lastEval > AutoScale.windowMs && now > AutoScale.warmupMs){
        const avgMs = AutoScale.accMs / AutoScale.frames;
        let changed = false;

        if (avgMs > AutoScale.lowFpsMs && currentScaleLevel < AutoScale.maxLevel){
          currentScaleLevel = Math.min(AutoScale.maxLevel, currentScaleLevel + AutoScale.step);
          changed = true;
        } else if (avgMs < AutoScale.highFpsMs && currentScaleLevel > AutoScale.minLevel){
          currentScaleLevel = Math.max(AutoScale.minLevel, currentScaleLevel - AutoScale.step);
          changed = true;
        }

        if (changed){
          applyHardwareScale(currentScaleLevel);
          if (glow){
            const base = IS_MOBILE ? 36 : 96;
            glow.blurKernelSize = Math.round( base * (0.9 + 0.2*(1 - (currentScaleLevel-0.33)/(1-0.33))) );
          }
        }
        AutoScale.accMs = 0; AutoScale.frames = 0; AutoScale.lastEval = now;
      }
    }
  });

  // Resize
  function handleResize(){
    applyHardwareScale();
    engine.resize(true);
  }
  window.addEventListener("resize", handleResize, { passive:true });
  window.addEventListener("orientationchange", handleResize);

  // Potlaƒçen√≠ iOS gesture
  document.addEventListener('gesturestart', e => { if (IS_IOS) { e.preventDefault(); } }, { passive:false });

  // Reset ikona
  const resetCamIcon = document.getElementById('resetCamIcon');
  if (resetCamIcon){
    resetCamIcon.addEventListener('click', resetCamera);
    resetCamIcon.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); resetCamera(); }
    });
  }

  // Fullscreen ikona (jen desktop ‚Äì CSS ji schov√°v√° na mobilech)
  const fullscreenIcon = document.getElementById('fullscreenIcon');
  if (fullscreenIcon){
    fullscreenIcon.addEventListener('click', toggleFullscreen);
    fullscreenIcon.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' || e.key === ' '){ e.preventDefault(); toggleFullscreen(); }
    });
    document.addEventListener('fullscreenchange', syncFsButton);
    document.addEventListener('webkitfullscreenchange', syncFsButton);
    document.addEventListener('mozfullscreenchange', syncFsButton);
    document.addEventListener('MSFullscreenChange', syncFsButton);
  }
  </script>
</body>
</html>
