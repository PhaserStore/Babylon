<!doctype html>

<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Virtual Gallery — Clean View</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />


  <style>
    :root{
      --txt:#fff; --txt-dim:#ccc;
      --safe-top: env(safe-area-inset-top);
      --safe-right: env(safe-area-inset-right);
      --safe-bottom: env(safe-area-inset-bottom);
      --safe-left: env(safe-area-inset-left);
      --bar-h: 54px;
      --btn-bg:#2b2b2b;
      --btn-bg-hover:#3a3a3a;
      --btn-brd:rgba(255,255,255,.15);
      --accent:#ff6a00;
    }
    html,body{
      width:100%; height:100%; margin:0; overflow:hidden; background:#111; color:var(--txt);
      font-family:'Poppins',sans-serif;
    }
    #renderCanvas{
      position:fixed; inset:0; display:block; touch-action:none; width:100vw; height:100vh;
      will-change: transform; transform: translateZ(0);
    }

    /* === SoundCloud full-width bottom bar (desktop only) === */
    #scBar{
      position:fixed; left:0; right:0; bottom:0;
      height:var(--bar-h); background:#1a1a1a;
      border-top:1px solid rgba(255,255,255,.15);
      display:flex; align-items:center; padding:0 14px; gap:20px;
      z-index:50; font-size:13px; color:#eee;
      -webkit-tap-highlight-color: transparent;
    }
    #scBar button{
      width:34px; height:34px; border-radius:8px; border:1px solid var(--btn-brd);
      background:var(--btn-bg); color:#fff; cursor:pointer; display:inline-grid; place-items:center; outline:none;
    }
    #scBar button:hover{ background:var(--btn-bg-hover); }
    #scBar button:focus-visible{ box-shadow: 0 0 0 2px rgba(255,255,255,.25); }
    .icon{ width:18px; height:18px; display:block; fill:#fff; pointer-events:none; }
    .sc-left{ display:flex; gap:6px; align-items:center; }
    .sc-center{ flex:1; display:flex; align-items:center; gap:10px; user-select:none; min-width:180px; }
    #scSeek{ flex:1; height:6px; background:#555; border-radius:4px; position:relative; cursor:pointer; }
    #scSeekFill{ position:absolute; left:0; top:0; bottom:0; width:0%; background:var(--accent); border-radius:4px; }
    .time{ min-width:40px; text-align:center; color:#ddd; font-variant-numeric: tabular-nums; }
    .sc-right{ display:flex; align-items:center; gap:12px; min-width:280px; }
    #scThumb{ width:34px; height:34px; border-radius:6px; object-fit:cover; }
    #barVol{ width:84px; }

    /* Ikony vpravo dole nad barem */
    .hudIcon{
      position:fixed; z-index:10000; width:56px; height:56px; cursor:pointer; user-select:none; -webkit-user-drag:none;
      filter: drop-shadow(0 8px 16px rgba(0,0,0,.45)); opacity:.96; transition: transform .12s ease, opacity .12s ease;
      right:calc(12px + var(--safe-right)); bottom:calc(12px + var(--bar-h) + var(--safe-bottom));
    }
    .hudIcon:hover{ transform:translateY(-1px); opacity:1; }
    /* fullscreen ikonu posuneme o šířku tlačítka + mezeru */
    #fullscreenIcon{ right:calc(12px + var(--safe-right) + 56px + 8px); }

    /* Desktop bar shrink */
    @media (max-width: 560px){
      #scBar{ gap:12px; padding:0 10px; }
      .sc-right{ min-width:200px; gap:10px; }
      #barVol{ width:70px; }
      .time{ display:none; }
    }

    /* MOBILE: schovat fullscreen ikonu i celý SC bar + host */
    @media (pointer:coarse), (max-width: 900px){
      #fullscreenIcon{ display:none !important; }
      #scBar, #scIframeHost{ display:none !important; }
    }
  </style>

  <!-- Babylon.js -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>

<body>
  <!-- Canvas -->
  <canvas id="renderCanvas"></canvas>

  <!-- Fullscreen (vlevo), Reset (vpravo) -->
  <img
    id="fullscreenIcon"
    class="hudIcon"
    src="https://raw.githubusercontent.com/PhaserStore/Babylon/main/assets/full%20screen.svg"
    alt="Celá obrazovka"
    title="Přepnout celé okno"
    role="button"
    tabindex="0"
    aria-label="Celá obrazovka"
    aria-pressed="false"
  />
  <img
    id="resetCamIcon"
    class="hudIcon"
    src="./assets/focus.svg"
    alt="Reset kamery"
    title="Reset kamery (R)"
    role="button"
    tabindex="0"
    aria-label="Reset kamery"
  />

  <!-- Desktop: SoundCloud bar -->
  <div id="scBar" aria-label="SoundCloud Bar">
    <div class="sc-left">
      <button id="barPrev" title="Previous" aria-label="Previous">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M11 6v12l-8-6 8-6zm10 0v12l-8-6 8-6z"/></svg>
      </button>
      <button id="barPlay" title="Play" aria-label="Play">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M8 5v14l11-7z"/></svg>
      </button>
      <button id="barPause" title="Pause" aria-label="Pause">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 5h4v14H6zM14 5h4v14h-4z"/></svg>
      </button>
      <button id="barNext" title="Next" aria-label="Next">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M13 6v12l8-6-8-6zM3 6v12l8-6-8-6z"/></svg>
      </button>
    </div>

    <div class="sc-center">
      <span id="scTimeCur" class="time">0:00</span>
      <div id="scSeek" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" tabindex="0">
        <div id="scSeekFill"></div>
      </div>
      <span id="scTimeDur" class="time">0:00</span>
    </div>

    <div class="sc-right">
      <button id="barMute" title="Mute/Unmute" aria-label="Mute or unmute">
        <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 9v6h4l5 5V4L8 9H4z"/></svg>
      </button>
      <input id="barVol" type="range" min="0" max="100" value="75" aria-label="Volume" />
      <img id="scThumb" src="" alt="cover" />
      <span id="scTitle">–</span>
    </div>
  </div>

  <!-- Host pro SC iframe: mimo viewport (desktop) -->
  <div id="scIframeHost" style="position:fixed; left:-99999px; top:-99999px; width:1px; height:1px; overflow:hidden; opacity:0; pointer-events:none;"></div>

  <script>
  "use strict";

  /* ========= Helpers & flags ========= */
  const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || Math.min(window.innerWidth, window.innerHeight) <= 900;
  const IS_IOS = /iP(ad|hone|od)/.test(navigator.userAgent);
  const SC_ENABLED = !IS_MOBILE; // mobil: SoundCloud zcela vypnutý

  const fmtTime = (ms)=> {
    const sec = Math.max(0, Math.floor((ms||0)/1000));
    const m = Math.floor(sec/60), s = sec%60;
    return `${m}:${s.toString().padStart(2,'0')}`;
  };

  const DPR = (()=> {
    const raw = window.devicePixelRatio || 1;
    const steps = [1, 1.25, 1.5, 2, 2.5, 3];
    let pick = steps[0], best = Infinity;
    for (const s of steps){ const d = Math.abs(s - raw); if (d < best){ best = d; pick = s; } }
    return pick;
  })();

  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, {
    preserveDrawingBuffer:false, stencil:true, antialias:true, adaptToDeviceRatio:false, powerPreference:"high-performance"
  });

  const sceneCaps = engine.getCaps ? engine.getCaps() : {};
  const MAX_TEX_CAP = Math.max(512, sceneCaps.maxTextureSize || 2048);
  const MOBILE_TEX_CAP  = Math.min(MAX_TEX_CAP, 768);
  const DESKTOP_TEX_CAP = Math.min(MAX_TEX_CAP, 4096);
  const TEX_BASE = IS_MOBILE ? 1048 : 768;
  const nearestPOT = (n, cap)=> Math.min(Math.pow(2, Math.round(Math.log2(Math.max(2, n)))), cap || n);
  let TEX_SIZE = Math.round(TEX_BASE * Math.min(DPR, 2));
  TEX_SIZE = nearestPOT(Math.min(TEX_SIZE, IS_MOBILE ? MOBILE_TEX_CAP : DESKTOP_TEX_CAP), IS_MOBILE ? MOBILE_TEX_CAP : DESKTOP_TEX_CAP);
  const MAX_ANISO = sceneCaps.maxAnisotropy || 4;

  /* ========= Scene setup ========= */
  let scene, camera, glow;
  const ROOM = { W:16, D:30, H:13 };
  const MIN_RADIUS = 0.28;

  const BASE_LEVEL = Math.max(0.33, Math.min(1 / DPR, 1));
  let currentScaleLevel = Math.round(BASE_LEVEL * 100) / 100;
  function applyHardwareScale(levelOverride){
    const lvl = typeof levelOverride === "number" ? levelOverride : currentScaleLevel;
    engine.setHardwareScalingLevel(Math.round(lvl * 100) / 100);
  }
  applyHardwareScale();

  const AutoScale = {
    enabled: IS_MOBILE, windowMs: 1200, warmupMs: 1500, lowFpsMs: 30, highFpsMs: 17,
    step: 0.05, minLevel: 0.33, maxLevel: 1.00, accMs: 0, frames: 0, lastEval: performance.now()
  };

  function unlit(hex){
    const m = new BABYLON.StandardMaterial("m", scene);
    m.diffuseColor = BABYLON.Color3.FromHexString(hex);
    m.disableLighting = true;
    m.backFaceCulling = false;
    m.specularColor = new BABYLON.Color3(0,0,0);
    return m;
  }
 // === PŮVODNÍ FUNKČNÍ ŘETĚZEC + ZESVĚTLENÍ (gain) ===
function unlitTex(tex, { doubleSided = false, gain = 1.18 } = {}) {
  const m = new BABYLON.StandardMaterial("mt", scene);
  m.disableLighting = true;

  // PONECHÁME původní kreslení přes diffuse (a klidně i emissive),
  // jen přidáme "bílé" emissive, aby se nic tlumením nestratilo.
  m.diffuseTexture  = tex;
  m.emissiveTexture = tex;
  m.emissiveColor   = new BABYLON.Color3(1, 1, 1);

  m.backFaceCulling = !doubleSided;
  m.specularColor   = new BABYLON.Color3(0, 0, 0);

  if (tex) {
    // sRGB vstup pro věrné barvy + mírné ZESVĚTLENÍ
    tex.gammaSpace = true;
    tex.level      = gain; // ← zvýší jas (např. 1.15–1.25)

    tex.wrapU = tex.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
    tex.updateSamplingMode(BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
    tex.anisotropicFilteringLevel = MAX_ANISO;
  }
  return m;
}
  function makeDT(name, w, h, genMipmaps=true) {
    const dt = new BABYLON.DynamicTexture(name,{ width:w, height:h },scene,genMipmaps,BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
    dt.wrapU = dt.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
    dt.hasAlpha = false;
    dt.anisotropicFilteringLevel = MAX_ANISO;
    return dt;
  }

  function buildMySkybox() {
    const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 2000 }, scene);
    skybox.isPickable = false; skybox.infiniteDistance = true; skybox.applyFog = false;

    const skyMat = new BABYLON.StandardMaterial("skyMat", scene);
    skyMat.backFaceCulling = false; skyMat.disableLighting = true;
    skyMat.diffuseColor = new BABYLON.Color3(0,0,0); skyMat.specularColor = new BABYLON.Color3(0,0,0); skyMat.emissiveColor = new BABYLON.Color3(0,0,0);

    const cubetex = BABYLON.CubeTexture.CreateFromImages([
      "./assets/mySky_px.png","./assets/mySky_nx.png","./assets/mySky_py.png",
      "./assets/mySky_ny.png","./assets/mySky_pz.png","./assets/mySky_nz.png"
    ], scene);
    cubetex.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    cubetex.updateSamplingMode(BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
    cubetex.level = 0.8; // lehce tmavší
    skyMat.reflectionTexture = cubetex;
    skybox.material = skyMat;
  }

  function buildRoom() {
    const floor = BABYLON.MeshBuilder.CreateGround("floor", { width: ROOM.W, height: ROOM.D }, scene);
    floor.material = unlit("#151515");

    const LED_TOP = ROOM.H - 0.04;
    const LIP = 0.005;
    const WALL_H = LED_TOP - LIP;
    const wallY  = WALL_H / 2;
    const OVER = 0.04;

    const back = BABYLON.MeshBuilder.CreatePlane("back", {
      width: ROOM.W + OVER, height: WALL_H, sideOrientation: BABYLON.Mesh.FRONTSIDE
    }, scene);
    back.position.set(0, wallY, -ROOM.D/2);
    back.material = unlit("#2b2b2b");

    const front = BABYLON.MeshBuilder.CreatePlane("front", {
      width: ROOM.W + OVER, height: WALL_H, sideOrientation: BABYLON.Mesh.FRONTSIDE
    }, scene);
    front.position.set(0, wallY, ROOM.D/2);
    front.rotation.y = Math.PI;
    front.material = unlit("#2b2b2b");

    const left = BABYLON.MeshBuilder.CreatePlane("leftWall", {
      width: ROOM.D + OVER, height: WALL_H, sideOrientation: BABYLON.Mesh.FRONTSIDE
    }, scene);
    left.position.set(-ROOM.W/2, wallY, 0);
    left.rotation.y = -Math.PI/2;
    left.material = unlit("#242424");

    const right = BABYLON.MeshBuilder.CreatePlane("rightWall", {
      width: ROOM.D + OVER, height: WALL_H, sideOrientation: BABYLON.Mesh.FRONTSIDE
    }, scene);
    right.position.set(ROOM.W/2, wallY, 0);
    right.rotation.y = Math.PI/2;
    right.material = unlit("#242424");
  }

  function buildCeilingWithAperture({ inw = 0.1 } = {}) {
    const y1 = ROOM.H - 0.04;
    const yCeil = y1 + 0.0005;

    const W = ROOM.W, D = ROOM.D;
    const openW = W - 2 * inw;
    const openD = D - 2 * inw;

    const mCeil = unlit("#111111");
    const part = (name,w,h,px,pz)=>{const p=BABYLON.MeshBuilder.CreatePlane(name,{width:w,height:h,sideOrientation:BABYLON.Mesh.FRONTSIDE},scene); p.position.set(px,yCeil,pz); p.rotation.x=Math.PI/2; p.material=mCeil; p.isPickable=false;};

    part("ceil_north", W, (D - openD)/2, 0, -(openD/2 + (D-openD)/4));
    part("ceil_south", W, (D - openD)/2, 0,  (openD/2 + (D-openD)/4));
    part("ceil_west",  (W - openW)/2, openD, -(openW/2 + (W-openW)/4), 0);
    part("ceil_east",  (W - openW)/2, openD,  +(openW/2 + (W-openW)/4), 0);

    const lipH = 0.02, mLip = unlit("#181818");
    const mkLip=(name,w,h,px,pz,ry=0)=>{const p=BABYLON.MeshBuilder.CreatePlane(name,{width:w,height:h,sideOrientation:BABYLON.Mesh.BACKSIDE},scene); p.position.set(px,y1 - lipH/2,pz); p.rotation.y=ry; p.material=mLip; p.isPickable=false;};
    mkLip("lip_north", openW, lipH, 0, -openD/2, 0);
    mkLip("lip_south", openW, lipH, 0,  openD/2, Math.PI);
    mkLip("lip_west",  openD, lipH, -openW/2, 0, -Math.PI/2);
    mkLip("lip_east",  openD, lipH,  openW/2, 0,  Math.PI/2);
  }

  function buildLED() {
    const n = new BABYLON.TransformNode("led", scene);
    const t = 0.02, inw = 0.1;

    const xL = -ROOM.W/2 + inw, xR = ROOM.W/2 - inw, zF = ROOM.D/2 - inw, zB = -ROOM.D/2 + inw;
    const y0 = 0.04, y1 = ROOM.H - 0.04;

    const mat = new BABYLON.StandardMaterial("ledMat", scene);
    mat.emissiveColor = BABYLON.Color3.FromHexString("#ffbdf6");
    mat.disableLighting = true;

    const seg = (a, b) => {
      const d = BABYLON.Vector3.Distance(a, b);
      const m = BABYLON.MeshBuilder.CreateBox("ledSeg", { width: t, height: t, depth: d }, scene);
      m.position = BABYLON.Vector3.Center(a, b); m.lookAt(b); m.rotation.x += Math.PI;
      m.material = mat; m.isPickable = false; m.parent = n; glow.addIncludedOnlyMesh(m);
    };

    [[xL,y0,zF,xR,y0,zF],[xR,y0,zF,xR,y0,zB],[xR,y0,zB,xL,y0,zB],[xL,y0,zB,xL,y0,zF],
     [xL,y1,zF,xR,y1,zF],[xR,y1,zF,xR,y1,zB],[xR,y1,zB,xL,y1,zB],[xL,y1,zB,xL,y1,zF]]
     .forEach(([ax,ay,az,bx,by,bz]) => seg(new BABYLON.Vector3(ax,ay,az), new BABYLON.Vector3(bx,by,bz)));
    [[xL,zF],[xR,zF],[xR,zB],[xL,zB]].forEach(([x,z]) => seg(new BABYLON.Vector3(x,y0,z), new BABYLON.Vector3(x,y1,z)));
  }

  function drawChecker(ctx, w, h) {
    const tile = 32;
    for (let y=0; y<h; y+=tile) for (let x=0; x<w; x+=tile){
      const even = ((x/tile)+(y/tile)) % 2 === 0;
      ctx.fillStyle = even ? "#dcdcdc" : "#f4f4f4"; ctx.fillRect(x, y, tile, tile);
    }
  }

  function fitDrawToCanvas(ctx, bmp, targetW, targetH, frameW, frameH, mode="cover", bg="#000") {
  const frameAspect = frameW / frameH;
  const imgAspect   = bmp.width / bmp.height;

  // ⭐ Pokud má obrázek téměř stejný poměr jako rám — NECHCEME mezery
  const nearlySame = Math.abs(imgAspect - frameAspect) < 0.02;  // tolerance 2 %

  let dw, dh, dx = 0, dy = 0;

  if (mode === "contain" && nearlySame) {
    // ⭐ PERFECT FIT for 9:16 images
    dw = targetW;
    dh = targetH;
    dx = 0;
    dy = 0;
  }
  else if (mode === "cover"){
    if (imgAspect > frameAspect){
      dh = targetH;
      dw = Math.round(dh * imgAspect);
      dx = Math.round((targetW - dw) / 2);
    } else {
      dw = targetW;
      dh = Math.round(dw / imgAspect);
      dy = Math.round((targetH - dh) / 2);
    }
  }
  else { // contain (standard)
    if (imgAspect > frameAspect){
      dw = targetW;
      dh = Math.round(dw / imgAspect);
      dy = Math.round((targetH - dh) / 2);
    } else {
      dh = targetH;
      dw = Math.round(dh * imgAspect);
      dx = Math.round((targetW - dw) / 2);
    }
  }

  if (bg){
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, targetW, targetH);
  }

  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.drawImage(bmp, 0, 0, bmp.width, bmp.height, dx, dy, dw, dh);
}

  /* ===== WebP POUZE PRO RÁMY ===== */

/* Kontrola WebP */
const isWebP = (u) => /\.webp$/i.test(u || "");

/* === Pomocná funkce: velikost textury v poměru rámu (9:16) === */
function getFrameTexSize() {
  const A = FRAME_SIZE.W / FRAME_SIZE.H;  // šířka/výška

  const cap = IS_MOBILE ? MOBILE_TEX_CAP : DESKTOP_TEX_CAP;

  // vyjdeme z TEX_SIZE, držíme power‑of‑two
  let texW = Math.min(TEX_SIZE, cap);
  texW = nearestPOT(texW, cap);

  let texH = Math.round(texW / A);
  texH = nearestPOT(Math.max(2, texH), cap);

  if (texH > cap) {
    texH = nearestPOT(cap, cap);
    texW = nearestPOT(Math.max(2, Math.round(texH * A)), cap);
  }
  return { texW, texH };
}

/* === Správné načtení WebP do rámu (bez deformace) === */
function setWebPToFrame(url, targetItem, texSize=TEX_SIZE, fitMode="cover") {
  if (!isWebP(url)) {
    console.warn("Pouze WebP je povolen pro rámové obrazy. Přeskakuji:", url);
    return;
  }
  const safeUrl = encodeURI(url);

  const img = new Image();
  if (!/^(\.|\/)/.test(safeUrl)) img.crossOrigin = "anonymous";
  img.decoding = "async";

  img.onload = () => {
    const { texW, texH } = getFrameTexSize(); // textura 9:16

    const dt = makeDT("imgDT_"+Math.random(), texW, texH, !IS_MOBILE);
    dt.gammaSpace = true; // zachovat sRGB
    const ctx = dt.getContext();

    fitDrawToCanvas(ctx, img, texW, texH, FRAME_SIZE.W, FRAME_SIZE.H, fitMode, "#000");
    dt.update();

    const mat = unlitTex(dt);
    mat.zOffset = -1;

    targetItem.frame.material = mat;
    console.log("[WebP] OK:", safeUrl);
  };

  img.onerror = (e) => {
    console.error("[WebP] Chyba načítání:", safeUrl, e);
  };

  img.src = safeUrl;
}

/* === Video do rámu s letterbox/pillarbox (bez deformace) === */
function setVideoToFrame(url, targetItem, { loop=true, muted=true, autoplay=true } = {}) {
  const vt = new BABYLON.VideoTexture(
    "vidTex_"+Math.random(), url, scene, true, false,
    BABYLON.Texture.TRILINEAR_SAMPLINGMODE,
    { autoPlay: autoplay, loop: loop, muted: muted }
  );

  try {
    vt.video.muted = !!muted;
    vt.video.loop = !!loop;
    vt.video.playsInline = true;
  } catch (e) {}

  vt.wrapU = vt.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
  vt.updateSamplingMode(BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
  vt.anisotropicFilteringLevel = MAX_ANISO;

  const mat = unlitTex(vt);
  mat.zOffset = -1;
  mat.diffuseColor = new BABYLON.Color3(0,0,0);

  targetItem.frame.material = mat;
  targetItem.videoTex = vt;

  const applyAspect = () => {
    const v = vt.video;
    if (!v || !v.videoWidth || !v.videoHeight) return;

    const r = v.videoWidth / v.videoHeight;
    const A = FRAME_SIZE.W / FRAME_SIZE.H;

    let uScale = 1, vScale = 1, uOffset = 0, vOffset = 0;

    if (r > A) {
      vScale = A / r;
      vOffset = (1 - vScale) / 2;
    } else if (r < A) {
      uScale = r / A;
      uOffset = (1 - uScale) / 2;
    }

    vt.uScale = uScale;
    vt.vScale = vScale;
    vt.uOffset = uOffset;
    vt.vOffset = vOffset;
  };

  if (vt.video) {
    vt.video.addEventListener('loadedmetadata', applyAspect, { once:true });
    applyAspect();
  }
}

/* === Konfigurace rámu === */
const FRAME_SIZE = { W: 2, H: 2 }; // H se později změní na 9:16
let FRAME_BOX_BORDER = 0.08;
let FRAME_COLOR = "#717171";
let FRAME_BASE_H = 2.2;
let FRAME_DELTA_H = 0;

/* === Rámový box — beze změny === */
function makeGradDT(name, w, h, {from="#7a7a7a", to="#555", vertical=true}={}){
  const dt = new BABYLON.DynamicTexture(name, {width:w, height:h}, scene, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
  const ctx = dt.getContext();
  ctx.clearRect(0,0,w,h);
  const g = vertical ? ctx.createLinearGradient(0,0,0,h) : ctx.createLinearGradient(0,0,w,0);
  g.addColorStop(0, from); g.addColorStop(1, to);
  ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
  dt.update();
  dt.wrapU = dt.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
  dt.anisotropicFilteringLevel = MAX_ANISO;
  return dt;
}
const lighten = (c,f)=> new BABYLON.Color3(
  Math.min(1, c.r + (1-c.r)*f),
  Math.min(1, c.g + (1-c.g)*f),
  Math.min(1, c.b + (1-c.b)*f)
);
const darken = (c,f)=> new BABYLON.Color3(c.r*(1-f), c.g*(1-f), c.b*(1-f));

function makeShadedFrameBoxMultiMat(baseHex = FRAME_COLOR){
  const c = BABYLON.Color3.FromHexString(baseHex);
  const mats = [
    makeGradDT("frm_front",256,256,{from:lighten(c,0.12).toHexString(), to:darken(c,0.18).toHexString()}),
    makeGradDT("frm_back",256,256,{from:darken(c,0.10).toHexString(), to:darken(c,0.10).toHexString()}),
    makeGradDT("frm_right",256,256,{from:lighten(c,0.08).toHexString(), to:darken(c,0.12).toHexString()}),
    makeGradDT("frm_left",256,256,{from:lighten(c,0.08).toHexString(), to:darken(c,0.12).toHexString()}),
    makeGradDT("frm_top",256,256,{from:lighten(c,0.20).toHexString(), to:lighten(c,0.20).toHexString()}),
    makeGradDT("frm_bottom",256,256,{from:darken(c,0.25).toHexString(), to:darken(c,0.25).toHexString()}),
  ].map((dt,i)=>{
    const m = new BABYLON.StandardMaterial("frmMat_"+i, scene);
    m.disableLighting = true;
    m.diffuseTexture = dt;
    m.emissiveTexture = dt;
    m.backFaceCulling = false;
    m.specularColor = new BABYLON.Color3(0,0,0);
    return m;
  });
  const mm = new BABYLON.MultiMaterial("frameBoxMM", scene);
  mats.forEach(m => mm.subMaterials.push(m));
  return mm;
}

/* === Cedulka zůstává stejná === */
function drawPlacard(plac, data, rotY, planeW, planeH){
  const texWFull = TEX_SIZE;
  const texWTarget = IS_MOBILE ? Math.max(256, Math.min(1024, Math.round(texWFull * 0.5))) : texWFull;
  const texW = nearestPOT(texWTarget, IS_MOBILE ? 1024 : 2048);
  const texH = nearestPOT(Math.max(64, Math.round(texW * (planeH / planeW))), texW);

  const dt = makeDT("pl", texW, texH, !IS_MOBILE);
  const c = dt.getContext();
  c.fillStyle = "#6b6b6b"; c.fillRect(0,0,texW,texH);

  const pad = Math.round(texH * 0.12);
  const maxW = texW - pad*2;

  c.fillStyle = "#ffffff"; c.textAlign = "center"; c.textBaseline = "top";
  const lineH = Math.round(texH * 0.34);
  const fontSize = Math.max(18, Math.round(lineH * 0.78));
  c.font = `600 ${fontSize}px Poppins`;

  const text = (data.title || "(bez názvu)").trim();
  const words = text.split(/\s+/);
  const lines = [];
  let buf = "";
  for (let w of words){
    const test = buf ? (buf + " " + w) : w;
    if (c.measureText(test).width <= maxW) buf = test;
    else { if (buf) lines.push(buf); buf = w; }
  }
  if (buf) lines.push(buf);
  const maxLines = 2;
  if (lines.length > maxLines){
    const keep = lines.slice(0, maxLines);
    let last = keep[maxLines-1];
    while (c.measureText(last + "…").width > maxW && last.length>0) last = last.slice(0,-1);
    keep[maxLines-1] = last + "…";
    lines.length = 0; Array.prototype.push.apply(lines, keep);
  }

  const blockH = lines.length * lineH;
  const startY = Math.max(pad, Math.round((texH - blockH)/2));
  lines.forEach((ln, i)=> c.fillText(ln, texW / 2, startY + i*lineH + Math.round(lineH*0.1)));

  dt.update();
  const mat = unlitTex(dt); mat.zOffset = -2;
  plac.material = mat;
}
/* === Posun po normále stěny (pro umístění plochy a cedulky) === */
function normalOffset(rotY, dist){
  const nx = Math.sin(rotY) * dist;
  const nz = Math.cos(rotY) * dist;
  return new BABYLON.Vector3(nx, 0, nz);
}
/* === Frame konstrukce — placeholder 9:16! === */
function addFrame(pos, rotY=0, wall='front'){
  const box = BABYLON.MeshBuilder.CreateBox("frameBox", {
    width: FRAME_SIZE.W + FRAME_BOX_BORDER,
    height: FRAME_SIZE.H + FRAME_BOX_BORDER,
    depth: 0.06
  }, scene);

  box.position = pos.add(normalOffset(rotY, 0.0));
  box.rotation.y = rotY;
  box.isPickable = true;

  box.subMeshes = [];
  const indices = box.getIndices();
  const verticesCount = box.getTotalVertices();
  let idx = 0;
  const perFace = indices.length / 6;
  for (let f=0; f<6; f++){
    new BABYLON.SubMesh(f, 0, verticesCount, idx, perFace, box);
    idx += perFace;
  }
  box.material = makeShadedFrameBoxMultiMat(FRAME_COLOR);

  // obrazová plocha
  const f = BABYLON.MeshBuilder.CreatePlane("frame", {
    width: FRAME_SIZE.W,
    height: FRAME_SIZE.H,
    sideOrientation: BABYLON.Mesh.FRONTSIDE
  }, scene);

  f.position = pos.add(normalOffset(rotY, 0.04));
  f.rotation.y = rotY + Math.PI;
  f.isPickable = true;

  // placeholder 9:16
  const { texW: phW, texH: phH } = getFrameTexSize();
  const dt = makeDT("ph_img", phW, phH, true);
  const ctx = dt.getContext();
  drawChecker(ctx, phW, phH);
  dt.update();
  const fMat = unlitTex(dt);
  fMat.zOffset = -1;
  f.material = fMat;

  // cedulka
  const placW = FRAME_SIZE.W;
  const placH = Math.max(0.22, FRAME_SIZE.H * 0.10);
  const plac = BABYLON.MeshBuilder.CreatePlane("plac", {
    width: placW, height: placH, sideOrientation: BABYLON.Mesh.FRONTSIDE
  }, scene);

  plac.position = pos.add(new BABYLON.Vector3(0, -FRAME_SIZE.H*0.83, 0)).add(normalOffset(rotY, 0.03));
  plac.rotation.y = rotY + Math.PI;
  plac.isPickable = true;

  const data = { title: "(bez názvu)", url: "", src: "" };
  drawPlacard(plac, data, rotY, placW, placH);

  return { frame:f, box, placard:plac, data, wall, rotY, pos };
}

  /* =========================
     LOGO – inline SVG (ostrý + glow) na zadní i přední stěnu
  ========================= */
  const GALLERY_LOGO_SVG = `
<svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 941.43 272.86" preserveAspectRatio="xMidYMid meet">
  <defs><style>.cls-1{fill:#daff3e;}</style></defs>
  <g>
    <path class="cls-1" d="M317.06,103.94h-76.71c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h76.71c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
    <path class="cls-1" d="M299.75,179.35c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l17.31-75.4c.46-2,2.46-3.25,4.45-2.79,2,.46,3.25,2.45,2.79,4.45l-17.31,75.4c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M222.8,180.12c-.28,0-.56-.03-.84-.1-2-.46-3.25-2.45-2.79-4.45l27.14-117.91c.46-2,2.45-3.25,4.46-2.79 2,.46 3.25,2.46 2.79,4.46l-27.14,117.91c-.4,1.72-1.93,2.88-3.62,2.88Z"/>
    <path class="cls-1" d="M439.3,179.34h-139.39c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h136.43l15.6-67.97h-70.53c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h75.2c1.13,0,2.2.52,2.91,1.4.71.89.97,2.04.72,3.15l-17.31,75.4c-.39,1.69-1.89,2.88-3.62,2.88Z"/>
    <path class="cls-1" d="M785.01,179.34c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l17.31-75.4c.39-1.69,1.89-2.88,3.62-2.88h76.96c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72h-74l-16.65,72.52c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M211.85,180.13l-170.7-.27c-2.05,0-3.71-1.67-3.71-3.72,0-2.05,1.67-3.71,3.72-3.71l170.7.27c2.05,0,3.71,1.67,3.71,3.72,0,2.05-1.67,3.71-3.72,3.71Z"/>
    <path class="cls-1" d="M72.27,221.31c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l26.94-117.36c.46-2,2.46-3.25,4.45-2.79,2,.46,3.25,2.45,2.79,4.45l-26.94,117.36c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M784.97,179.34h-141.2c-1.13,0-2.2-.52-2.91-1.4-.71-.89-.97-2.04-.72-3.15l17.31-75.4c.39-1.69,1.89-2.88,3.62-2.88h76.41c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72h-73.45l-15.6,67.97h136.53c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
    <path class="cls-1" d="M158.76,180.12c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l16.44-71.63h-72.37c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h77.03c1.13,0,2.2.52,2.91,1.4.71.89.97,2.04.71,3.15l-17.49,76.18c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M222.74,180.13l-182.02-.27c-2.05,0-3.71-1.67-3.71-3.72,0-2.05,1.67-3.71,3.72-3.71l182.02.27c2.05,0,3.71,1.67,3.71,3.72,0,2.05-1.67,3.71-3.72,3.71Z"/>
    <path class="cls-1" d="M602.74,212.29c-.55,0-1.09-.12-1.61-.37-.76-.36-1.35-.96-1.71-1.68l-103.95-136.78-129.09,105.46c-1.59,1.3-3.93,1.06-5.23-.53-1.3-1.59-1.06-3.93.53-5.23l131.89-107.74c.39-.36.86-.64,1.38-.81,1.5-.48,3.14.02,4.1,1.28l104.39,137.36 131.99-105.98c1.6-1.29,3.94-1.03,5.22.57 1.28,1.6 1.03,3.94-.57,5.22l-135.02,108.4c-.67.54-1.5.82-2.33.82Z"/>
  </g>
  <g>
    <path class="cls-1" d="M596.11,104.5h-75.2c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h75.2c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
    <path class="cls-1" d="M577.73,179.9h-74.12c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h74.12c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
  </g>
</svg>`;
  const LOGO_ASPECT = 941.43 / 202.86;
  const LOGO_SCALE = 0.30;
  const FRONT_BACK_OFFSET = 0.25;
  const LOGO_HEIGHT_M = 6.30;
  const GLOW_BLUR_PX = 18;
    
// Malá utilita – můžeš klidně nechat jen console.log
function hint(msg){ console.log(msg); }
    
  function buildGalleryLogo(){
    const img = new Image();
    img.src = "data:image/svg+xml;utf8," + encodeURIComponent(GALLERY_LOGO_SVG);
    img.onload = () => {
      const SIZE = 1024;
      const dt  = new BABYLON.DynamicTexture("logoDT",{width:SIZE,height:SIZE},scene,true);
      const ctx = dt.getContext();
      const maxW = SIZE * 0.92;
      const w = maxW, h = Math.round(maxW / LOGO_ASPECT);
      const x = Math.round((SIZE - w)/2), y = Math.round((SIZE - h)/2);
      ctx.clearRect(0,0,SIZE,SIZE); ctx.drawImage(img, x, y, w, h); dt.update();

      const glowDT = new BABYLON.DynamicTexture("logoGlowDT",{width:SIZE,height:SIZE},scene,true);
      const gc = glowDT.getContext();
      gc.clearRect(0,0,SIZE,SIZE); gc.filter = `blur(${GLOW_BLUR_PX}px)`; gc.drawImage(img, x, y, w, h); glowDT.update();

      const sharpMat = new BABYLON.StandardMaterial("logoSharpMat", scene);
      sharpMat.disableLighting = true; sharpMat.diffuseTexture  = dt; sharpMat.opacityTexture  = dt;
      sharpMat.emissiveColor   = new BABYLON.Color3(1,1,1); sharpMat.backFaceCulling = false;

      const glowMat = new BABYLON.StandardMaterial("logoGlowMat", scene);
      glowMat.disableLighting  = true; glowMat.emissiveTexture  = glowDT; glowMat.opacityTexture   = glowDT;
      glowMat.emissiveColor    = new BABYLON.Color3(1,1,1); glowMat.backFaceCulling  = false;

      const logoW = ROOM.W * LOGO_SCALE;
      const logoH = LOGO_HEIGHT_M;
      const yPos = ROOM.H*0.55 + FRAME_SIZE.H*0.95 + 0.80;

      function placeLogo(z, rotY, idx){
        const g = BABYLON.MeshBuilder.CreatePlane(`logoGlow_${idx}`, { width:logoW, height:logoH }, scene);
        g.position.set(0, yPos, z - Math.sign(z)*0.005); g.rotation.y = rotY; g.material = glowMat; glow.addIncludedOnlyMesh(g);

        const s = BABYLON.MeshBuilder.CreatePlane(`logoSharp_${idx}`, { width:logoW, height:logoH }, scene);
        s.position.set(0, yPos, z + Math.sign(z)*0.005); s.rotation.y = rotY; s.material = sharpMat;
      }
      // zadní + přední stěna
      placeLogo(-ROOM.D/2 + FRONT_BACK_OFFSET, Math.PI, 0);
      placeLogo( ROOM.D/2 - FRONT_BACK_OFFSET, 0,       1);
      hint("Logo (inline SVG) zobrazeno ✔  (glow aktivní)");
    };
    img.onerror = (e) => { console.error("Logo SVG nešlo dekódovat.", e); hint("Chyba: logo SVG nešlo dekódovat."); };
  }
    


  /* ========= Frames & layout ========= */
  const framesByWall = { back: [], front: [], left: [], right: [] };
  const FIXED_LAYOUT = {
    safeWall: 1.0, cornerSafe: 1.0,
    frame: { width: 2.2, height: 2.2, border: 0.08, color: "#717171" },
    counts: { front: 4, back: 4, left: 7, right: 7 }
  };

  /* UPRAV CESTY NA SVÉ .webp SOUBORY */
  const DATA = {
    front: [
      { img: "./assets/Acid_T.webp", label: "Acid T", href: "https://everpress.com/the-future-phaser-collection2" },
      { img: "./assets/Acid_T.webp",   label: "Produkt B", href: "https://example.com/b" },
      { img: "./assets/Acid_T.webp", label: "Produkt C", href: "https://example.com/c" },
      { img: "./assets/Acid_T.webp",   label: "Produkt D", href: "https://example.com/d" }
    ],
    back: [
      { img: "./assets/Acid_T.webp", label: "Back A", href: "https://example.com/a" },
      { img: "./assets/Acid_T.webp",   label: "Back B", href: "https://example.com/b" },
      { img: "./assets/Acid_T.webp", label: "Back C", href: "https://example.com/c" },
      { img: "./assets/Acid_T.webp",   label: "Back D", href: "https://example.com/d" }
    ],
    left: [
      { img: "./assets/Acid_T.webp", label: "Levá 1", href: "https://example.com/left-1" },
      { img: "./assets/Acid_T.webp",   label: "Levá 2", href: "https://example.com/left-2" },
      { img: "./assets/Acid_T.webp", label: "Levá 3", href: "https://example.com/left-3" },
      { img: "./assets/Acid_T.webp", label: "Levá 4", href: "https://example.com/left-4" },
      { img: "./assets/Acid_T.webp",   label: "Levá 5", href: "https://example.com/left-5" },
      { img: "./assets/Acid_T.webp", label: "Levá 6", href: "https://example.com/left-6" },
      { img: "./assets/Acid_T.webp",   label: "Levá 7", href: "https://example.com/left-7" }
    ],
    right: [
      { img: "./assets/Acid_T.webp",   label: "Pravá 1", href: "https://example.com/right-1" },
      { img: "./assets/Acid_T.webp", label: "Pravá 2", href: "https://example.com/right-2" },
      { img: "./assets/Acid_T.webp",   label: "Pravá 3", href: "https://example.com/right-3" },
      { img: "./assets/Acid_T.webp",   label: "Pravá 4", href: "https://example.com/right-4" },
      { img: "./assets/Acid_T.webp", label: "Pravá 5", href: "https://example.com/right-5" },
      { img: "./assets/Acid_T.webp",   label: "Pravá 6", href: "https://example.com/right-6" },
      { img: "./assets/Acid_T.webp",   label: "Pravá 7", href: "https://example.com/right-7" }
    ]
  };

  function distributeCenters(min, max, count, frameW){
    if (count <= 1) return [ (min+max)/2 ];
    const span = max - min, totalFramesWidth = count * frameW;
    let gap = (span - totalFramesWidth) / (count - 1);
    const MIN_GAP = 0.05; if (gap < MIN_GAP) gap = Math.max(gap, MIN_GAP);
    const centers = []; let x = min + frameW/2;
    for (let i=0; i<count; i++){ centers.push(x); x += frameW + gap; }
    if (centers[centers.length-1] > max - frameW/2 + 1e-6) {
      const step = (max - min) / (count - 1);
      centers.length = 0;
      for (let i=0;i<count;i++) centers.push(min + i*step);
    }
    return centers;
  }
  function createFixedFramesForWall(wall, count, centerY, safeWall, cornerSafe){
    const rotY = wall==='front' ? Math.PI : wall==='back' ? 0 : wall==='left' ? Math.PI/2 : -Math.PI/2;
    const axisX  = (wall==='front'||wall==='back');
    const length = axisX ? ROOM.W : ROOM.D;

    const min = -length/2 + safeWall + cornerSafe;
    const max =  length/2 - safeWall - cornerSafe;

    const frameW = FRAME_SIZE.W || FIXED_LAYOUT.frame.width;
    const centers = distributeCenters(min, max, count, frameW);

    framesByWall[wall].forEach(it => { it.frame.dispose(); it.box.dispose(); it.placard.dispose(); });
    framesByWall[wall] = [];

    centers.forEach(val=>{
      const pos = axisX
        ? new BABYLON.Vector3(val, centerY, (wall==='front' ? ROOM.D/2 - 0.03 : -ROOM.D/2 + 0.03))
        : new BABYLON.Vector3((wall==='right' ? ROOM.W/2 - 0.03 : -ROOM.W/2 + 0.03), centerY, val);
      const it = addFrame(pos, rotY, wall);
      framesByWall[wall].push(it);
    });
  }

  function assignDataAllWalls(data){
  const isVideoUrl = (u) => /\.(mp4|webm|ogg)$/i.test(u || "");
  const isWebPUrl  = (u) => /\.webp$/i.test(u || "");

  ["front","back","left","right"].forEach(side=>{
    const items = data[side] || [];
    const arr   = framesByWall[side] || [];
    const n = Math.min(items.length, arr.length);

    for (let i=0; i<n; i++){
      const it = arr[i];
      const d  = items[i] || {};
      const src = d.src || d.video || d.img || "";

      it.data.src   = src;
      it.data.title = d.label || it.data.title || "(bez názvu)";
      it.data.url   = d.href  || it.data.url || "";

      // Cedulka pod rámem
      drawPlacard(
        it.placard,
        it.data,
        it.rotY,
        it.placard._width  || FRAME_SIZE.W,
        it.placard._height || Math.max(0.22, FRAME_SIZE.H*0.10)
      );

      if (!src) continue;

      if (isVideoUrl(src)) {
        // VIDEO: letterbox/pillarbox
        setVideoToFrame(src, it, {
          loop:  d.loop   !== false,
          muted: d.muted  !== false,
          autoplay: true
        });
      }
      else if (isWebPUrl(src)) {
        // OBRÁZEK: zobrazit celý bez ořezu (contain)
        // Volitelně: per‑item můžeš dopsat do DATA: fit:"cover" | "contain"
        const fit = d.fit || "contain";
        setWebPToFrame(src, it, TEX_SIZE, fit);
      }
      else {
        console.warn("Pouze WebP je povolen pro rámové obrazy. Přeskakuji:", src);
        // placeholder zůstává
      }
    }
  });
}

  /* ========= Picking & zoom ========= */
  function setupPicking(){
    scene.onPointerObservable.add((pi)=>{
      if (pi.type !== BABYLON.PointerEventTypes.POINTERPICK) return;
      if (!pi.pickInfo?.hit) return;
      const mesh = pi.pickInfo.pickedMesh;
      for(const wall of Object.keys(framesByWall)){
        for(const it of framesByWall[wall]){
          if (mesh === it.placard && it.data.url){ window.open(it.data.url,"_blank","noopener"); return; }
        }
      }
    }, BABYLON.PointerEventTypes.POINTERPICK);
  }
  function zoomToPointer(px, py, {scale=0.55, forceMin=false}={}){
    const pick = scene.pick(px, py); if(!pick?.hit) return;
    camera.setTarget(pick.pickedPoint.clone());
    camera.radius = forceMin ? MIN_RADIUS : Math.max(MIN_RADIUS, camera.radius * scale);
  }
  function setupZoomUX(){
    const canvasEl = canvas;
    canvasEl.addEventListener("dblclick", ()=>{
      zoomToPointer(scene.pointerX, scene.pointerY, {
        scale: camera.radius < 1.2 ? 1.0 : 0.55,
        forceMin: camera.radius < 0.6
      });
    }, { passive:true });
    let lastTap = 0;
    canvasEl.addEventListener("touchend", (e)=>{
      const now = Date.now(); const dt  = now - lastTap; lastTap = now;
      if (dt > 280) return;
      const t = e.changedTouches && e.changedTouches[0]; if (!t) return;
      const rect = canvasEl.getBoundingClientRect();
      const x = t.clientX - rect.left; const y = t.clientY - rect.top;
      zoomToPointer(x, y, { scale: camera.radius < 1.2 ? 1.0 : 0.55, forceMin: camera.radius < 0.6 });
    }, { passive:true });
  }

  /* ========= Camera reset (opraveno + animace) ========= */
  // Střed viditelné výšky stěn: (ROOM.H - 0.04) je LED_TOP a -0.005 je lip
const WALL_CENTER_Y = (ROOM.H - 0.04 - 0.005) / 2;
    
    const RESET_POSE = {
  // Target uprostřed místnosti – ať jsou "v dosahu" všechny stěny
  target: new BABYLON.Vector3(0, WALL_CENTER_Y, 0),

  // Dálka od středu – základ pro 16:9; klidně dolaď o ±0.5
  radius: 17.0,

  // Směr na PŘEDNÍ stěnu (+Z)
  alpha:  Math.PI / 2,

  // Lehce NAD horizontem → víc oblohy, ale pořád vycentrovaný dojem na výšku
  // (pro "o chlup výš" zkus 1.86–1.92; menší hodnota = víc vzhůru)
  beta:   Math.PI / 1.88
};

    

  function animateCameraTo({alpha, beta, radius, target}, durationMs=400){
    if (!camera) return;

    const fps = 60, frames = Math.max(1, Math.round(durationMs / (1000/fps)));
    const easing = new BABYLON.CubicEase(); easing.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);

    const makeAnim = (prop, from, to) => {
      const a = new BABYLON.Animation("anim_"+prop, prop, fps, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
      a.setKeys([{frame:0, value:from}, {frame:frames, value:to}]);
      a.setEasingFunction(easing);
      return a;
    };

    // alpha, beta, radius
    const anims = [
      makeAnim("alpha",  camera.alpha,  alpha),
      makeAnim("beta",   camera.beta,   beta),
      makeAnim("radius", camera.radius, radius),
    ];

    // target (Vector3) – animujeme po složkách
    const makeVAnim = (axis, from, to) => {
      const a = new BABYLON.Animation("anim_t"+axis, "target."+axis, fps, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
      a.setKeys([{frame:0, value:from}, {frame:frames, value:to}]);
      a.setEasingFunction(easing);
      return a;
    };
    anims.push(
      makeVAnim("x", camera.target.x, target.x),
      makeVAnim("y", camera.target.y, target.y),
      makeVAnim("z", camera.target.z, target.z)
    );

    camera.animations = anims;
    scene.beginAnimation(camera, 0, frames, false);
  }

  function resetCamera({animate=true} = {}){
    if (!camera) return;
    if (animate){
      animateCameraTo(RESET_POSE, 420);
    } else {
      camera.alpha  = RESET_POSE.alpha;
      camera.beta   = RESET_POSE.beta;
      camera.radius = RESET_POSE.radius;
      camera.setTarget(RESET_POSE.target.clone()); // DŮLEŽITÉ: nový vektor do targetu
    }
  }

  function isFullscreen(){
    return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
  }
  function requestFs(el){
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
    if (req) req.call(el);
  }
  function exitFs(){
    const ex = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
    if (ex) ex.call(document);
  }
  function toggleFullscreen(){ if (isFullscreen()) exitFs(); else requestFs(document.documentElement); }
  function syncFsButton(){
    const btn = document.getElementById('fullscreenIcon'); if (!btn) return;
    const on = isFullscreen();
    btn.setAttribute('aria-pressed', on ? 'true' : 'false');
    btn.title = on ? 'Ukončit celé okno (Esc)' : 'Přepnout celé okno';
  }

  /* ========= Scene creation ========= */
function createScene(){
  scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(0,0,0,1);

  camera = new BABYLON.ArcRotateCamera("cam", RESET_POSE.alpha, RESET_POSE.beta, RESET_POSE.radius, RESET_POSE.target.clone(), scene);
  camera.attachControl(canvas, true);

  camera.minZ = 0.05;
  camera.maxZ = 5000;
  camera.lowerRadiusLimit = MIN_RADIUS;
  camera.upperRadiusLimit = 40;
  camera.lowerBetaLimit = 0.05;
  camera.upperBetaLimit = Math.PI - 0.05;

  new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);

  glow = new BABYLON.GlowLayer("gl", scene, { blurKernelSize: IS_MOBILE ? 16 : 28 });
  glow.intensity = IS_MOBILE ? 0.45 : 0.65;

  // Vypnout image processing
  scene.imageProcessingConfiguration.isEnabled = false;
  scene.imageProcessingConfiguration.applyByPostProcess = false;
  scene.imageProcessingConfiguration.toneMappingEnabled = false;
  scene.imageProcessingConfiguration.exposure = 1.0;
  scene.imageProcessingConfiguration.contrast = 1.0;

  buildRoom();
  buildLED();
  buildGalleryLogo();
  buildMySkybox();
  buildCeilingWithAperture({ inw: 0.1 });

  setupPicking();
  setupZoomUX();
  return scene;
}
/* ========= Shooting star with TRAIL (single, above the skylight only) ========= */

/** Rozměry otvoru ve stropě (musí sedět s buildCeilingWithAperture({ inw: 0.1 })) */
const APERTURE_INSET = 0.1;                     // stejné "inw" jako v buildCeilingWithAperture
const CEIL_Y = ROOM.H - 0.04;                   // výška spodní hrany "límce" stropu
const OPEN_W = ROOM.W - 2 * APERTURE_INSET;     // šířka otvoru
const OPEN_D = ROOM.D - 2 * APERTURE_INSET;     // délka otvoru

/** Nastavení intervalu výskytu jedné hvězdy */
const STAR_INTERVAL_MIN_MS = 6000;              // 6 s
const STAR_INTERVAL_MAX_MS = 12000;             // 12 s

/** Vytvoří jednu "padající hvězdu" (hlavička + trail) a odanimuje ji po úsečce nad stropem.
 *  POZOR: Babylon.js v8 → new TrailMesh(name, generator, scene, diameter, length, autoStart)
 */
function spawnOneShootingStar({
  start,                                   // {x,z} v rámci otvoru (zadní hrana)
  end,                                     // {x,z} v rámci otvoru (přední hrana)
  yTop = CEIL_Y + 1.40,                    // start výš
  yBot = CEIL_Y + 0.85,                    // cíl níž (pořád nad stropem)
  lifeSec = 0.85,                          // kratší = rychlejší let (0.75–1.1 doporučeno)
  size = 0.16,                             // menší hlavička
  color = new BABYLON.Color3(1, 1, 1)      // případně lehce modrá: (0.9, 0.95, 1)
}){
  // Hlavička (emisivní kulička)
  const head = BABYLON.MeshBuilder.CreateSphere("shootHead", { diameter: size }, scene);
  head.position.set(start.x, yTop, start.z);
  head.renderingGroupId = 1;

  const mHead = new BABYLON.StandardMaterial("shootHeadMat", scene);
  mHead.disableLighting = true;
  mHead.emissiveColor = color;
  mHead.specularColor = new BABYLON.Color3(0,0,0);
  head.material = mHead;

  // TrailMesh — TENKÁ a DELŠÍ čára (správné pořadí parametrů pro BJS v8!)
  const trailWidth  = size * 0.35;   // tenká stopa
  const trailPoints = 96;            // delší čára (zvyšte pro ještě delší stopu)
  const trail = new BABYLON.TrailMesh("shootTrail", head, scene, trailWidth, trailPoints, true);
  trail.renderingGroupId = 1;

  const mTrail = new BABYLON.StandardMaterial("shootTrailMat", scene);
  mTrail.disableLighting = true;
  mTrail.emissiveColor = color;
  mTrail.alpha = 0.95;
  mTrail.backFaceCulling = false;
  trail.material = mTrail;

  // (volitelné) zvýraznit glow layerem
  try { glow?.addIncludedOnlyMesh(head); glow?.addIncludedOnlyMesh(trail); } catch(e){}

  // Animace po úsečce A → B, s mírným poklesem Y z yTop → yBot (ale nikdy pod CEIL_Y + 0.75)
  const A = new BABYLON.Vector3(start.x, yTop, start.z);
  const B = new BABYLON.Vector3(end.x,   yBot, end.z);
  const minY = CEIL_Y + 0.75;

  const t0 = performance.now();
  const totalMs = lifeSec * 1000;

  const obs = scene.onBeforeRenderObservable.add(()=>{
    const t = performance.now();
    const r = Math.min(1, (t - t0) / totalMs);

    // jemné vlnění (menší, aby čára působila „ostřeji“)
    const wob = 0.012;
    const px = BABYLON.Scalar.Lerp(A.x, B.x, r) + Math.sin(t * 0.010) * wob;
    const py = Math.max(minY, BABYLON.Scalar.Lerp(A.y, B.y, r));
    const pz = BABYLON.Scalar.Lerp(A.z, B.z, r) + Math.cos(t * 0.012) * wob * 0.5;

    head.position.set(px, py, pz);

    if (r >= 1){
      scene.onBeforeRenderObservable.remove(obs);

      // rychlé dohasnutí (fade)
      const tFade0 = performance.now();
      const fadeMs = 200;
      const obs2 = scene.onBeforeRenderObservable.add(()=>{
        const rf = Math.min(1, (performance.now() - tFade0) / fadeMs);
        mTrail.alpha = 0.95 * (1 - rf);
        mHead.emissiveColor = color.scale(1 - rf);

        if (rf >= 1){
          scene.onBeforeRenderObservable.remove(obs2);
          try { glow?.removeIncludedOnlyMesh(head); glow?.removeIncludedOnlyMesh(trail); } catch(e){}
          trail.dispose(); mTrail.dispose?.();
          head.dispose();  mHead.dispose?.();
        }
      });
    }
  });
}

/** Vždy letí zezadu dopředu (směr k přední stěně) v rámci otvoru */
function pickEdgePoints(){
  const halfW = OPEN_W/2 - 0.15;           // malá rezerva od rámu
  const halfD = OPEN_D/2 - 0.15;

  // X náhodně v šířce otvoru, start na zadní hraně (−Z), konec na přední (+Z)
  const x = BABYLON.Scalar.RandomRange(-halfW, halfW);
  const start = { x, z: -halfD };
  const end   = { x: x + BABYLON.Scalar.RandomRange(-0.18, 0.18), z: +halfD };

  return { start, end };
}

let shootingTimer = null;

/** Naplánuje jednu hvězdu a po ní další s náhodným intervalem (6–12 s) */
function scheduleShootingStar(){
  const wait = STAR_INTERVAL_MIN_MS + Math.random() * (STAR_INTERVAL_MAX_MS - STAR_INTERVAL_MIN_MS);

  shootingTimer = setTimeout(()=>{
    const { start, end } = pickEdgePoints();

    // kratší život = rychlejší průlet; menší hlavička = subtilnější čára
    const life = BABYLON.Scalar.RandomRange(0.75, 1.10);
    const size = BABYLON.Scalar.RandomRange(0.14, 0.18);
    const yTop = CEIL_Y + 1.40;   // vždy nad stropem
    const yBot = CEIL_Y + 0.85;
    const color = new BABYLON.Color3(1, 1, 1);

    spawnOneShootingStar({ start, end, yTop, yBot, lifeSec: life, size, color });
    scheduleShootingStar(); // plánuj další
  }, wait);
}

function startShootingStars(){
  if (shootingTimer) clearTimeout(shootingTimer);
  scheduleShootingStar();
}
function stopShootingStars(){
  if (shootingTimer){ clearTimeout(shootingTimer); shootingTimer = null; }
}
``
  /* ========= Layout apply ========= */
  function applyFixedLayout() {
    const YCENTER = ROOM.H * 0.55;
    const safeWall   = FIXED_LAYOUT.safeWall;
    const cornerSafe = FIXED_LAYOUT.cornerSafe;

    const baseW = FIXED_LAYOUT.frame.width;   // 2.2
    const baseH = FIXED_LAYOUT.frame.height;  // 2.2
    FRAME_BASE_H = baseH;

    // portrait 9:16
    const newW = baseW;
    const newH = baseW * (16/9);

    FRAME_SIZE.W     = newW;
    FRAME_SIZE.H     = newH;
    FRAME_BOX_BORDER = FIXED_LAYOUT.frame.border;
    FRAME_COLOR      = FIXED_LAYOUT.frame.color;

    FRAME_DELTA_H = newH - baseH;
    const centerY = YCENTER - FRAME_DELTA_H/2; // ukotvení nahoře

    createFixedFramesForWall('front', FIXED_LAYOUT.counts.front,  centerY, safeWall, cornerSafe);
    createFixedFramesForWall('back',  FIXED_LAYOUT.counts.back,   centerY, safeWall, cornerSafe);
    createFixedFramesForWall('left',  FIXED_LAYOUT.counts.left,   centerY, safeWall, cornerSafe);
    createFixedFramesForWall('right', FIXED_LAYOUT.counts.right,  centerY, safeWall, cornerSafe);

    assignDataAllWalls(DATA);
  }

  /* ========= Soft camera bounds – keep camera inside the room ========= */
  const CAM_MARGIN = 0.55;
  const CAM_BOUNDS = {
    minX: -ROOM.W/2 + CAM_MARGIN,
    maxX:  ROOM.W/2 - CAM_MARGIN,
    minZ: -ROOM.D/2 + CAM_MARGIN,
    maxZ:  ROOM.D/2 - CAM_MARGIN,
    minY:  0.6,
    maxY:  ROOM.H - 0.6
  };

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function getOrbitDir(alpha, beta){
    const sinBeta = Math.sin(beta);
    return new BABYLON.Vector3(
      Math.cos(alpha) * sinBeta,
      Math.cos(beta),
      Math.sin(alpha) * sinBeta
    );
  }
  function constrainTarget(){
    const t = camera.target;
    t.x = clamp(t.x, CAM_BOUNDS.minX, CAM_BOUNDS.maxX);
    t.y = clamp(t.y, CAM_BOUNDS.minY, CAM_BOUNDS.maxY);
    t.z = clamp(t.z, CAM_BOUNDS.minZ, CAM_BOUNDS.maxZ);
    camera.setTarget(t); // jistota
  }
  function constrainCameraRadius(){
    const t = camera.target;
    const dir = getOrbitDir(camera.alpha, camera.beta);
    let rMax = camera.upperRadiusLimit || 1e9;
    if (dir.x > 1e-6)   rMax = Math.min(rMax, (CAM_BOUNDS.maxX - t.x) / dir.x);
    else if (dir.x < -1e-6) rMax = Math.min(rMax, (CAM_BOUNDS.minX - t.x) / dir.x);
    if (dir.y > 1e-6)   rMax = Math.min(rMax, (CAM_BOUNDS.maxY - t.y) / dir.y);
    else if (dir.y < -1e-6) rMax = Math.min(rMax, (CAM_BOUNDS.minY - t.y) / dir.y);
    if (dir.z > 1e-6)   rMax = Math.min(rMax, (CAM_BOUNDS.maxZ - t.z) / dir.z);
    else if (dir.z < -1e-6) rMax = Math.min(rMax, (CAM_BOUNDS.minZ - t.z) / dir.z);
    camera.radius = clamp(camera.radius, MIN_RADIUS, rMax);
  }

  /* ========= SoundCloud (desktop only) ========= */
  const SC_PLAYLIST_URL = "https://soundcloud.com/vertigo01/sets/detroit-techno";
  let scWidget = null, scReady = false, scLoading = false, scDuration = 0;

  function loadScApiOnce(){
    return new Promise((resolve, reject)=>{
      if (!SC_ENABLED) return resolve();
      if (window.SC && window.SC.Widget) return resolve();
      const s = document.createElement('script');
      s.src = "https://w.soundcloud.com/player/api.js";
      s.async = true;
      s.onload = ()=> resolve();
      s.onerror = ()=> reject(new Error("SC API failed to load"));
      document.head.appendChild(s);
    });
  }
  function mountScIframeOnce(){
    return new Promise((resolve)=>{
      if (!SC_ENABLED) return resolve(null);
      const host = document.getElementById('scIframeHost');
      let iframe = host.querySelector('iframe');
      if (iframe) return resolve(iframe);
      const url = "https://w.soundcloud.com/player/?"
        + "url=" + encodeURIComponent(SC_PLAYLIST_URL)
        + "&auto_play=false&hide_related=false&show_comments=false"
        + "&show_user=true&show_reposts=false&show_teaser=false&visual=false";
      const iframeEl = document.createElement('iframe');
      iframeEl.id = "scIframe"; iframeEl.title = "SoundCloud Player";
      iframeEl.setAttribute("allow", "autoplay; encrypted-media; clipboard-write");
      iframeEl.setAttribute("scrolling","no"); iframeEl.setAttribute("frameborder","no");
      iframeEl.style.width  = "1px"; iframeEl.style.height = "1px"; iframeEl.style.border = "0";
      iframeEl.src = url; host.appendChild(iframeEl);
      resolve(iframeEl);
    });
  }
  function scUpdateTime(cur, dur){
    const curEl = document.getElementById("scTimeCur");
    const durEl = document.getElementById("scTimeDur");
    if (curEl) curEl.textContent = fmtTime(cur);
    if (durEl) durEl.textContent = fmtTime(dur);
  }
  function scUpdateThumb(s){
    const t = document.getElementById("scThumb"); if (!t) return;
    let art = s?.artwork_url || s?.user?.avatar_url || "";
    if (art) art = art.replace("-large.jpg","-t200x200.jpg");
    t.src = art || "";
  }
  function scUpdateTitle(s){
    const el = document.getElementById("scTitle"); if (!el) return;
    el.textContent = s ? (s.title || "Unknown") : "–";
  }
  function scUpdateProgress(rel){
    const fill = document.getElementById("scSeekFill"); if (!fill) return;
    fill.style.width = (Math.max(0, Math.min(1, rel)) * 100).toFixed(2) + "%";
  }
  function initScWidgetOnce(){
    return new Promise((resolve)=>{
      if (!SC_ENABLED) return resolve(null);
      const iframe = document.getElementById('scIframe');
      if (!iframe || !window.SC || !window.SC.Widget) return resolve(null);
      if (scWidget) return resolve(scWidget);
      scWidget = window.SC.Widget(iframe);
      scWidget.bind(window.SC.Widget.Events.READY, ()=>{
        scReady = true;
        const barVol = document.getElementById('barVol');
        const vol = Math.max(0, Math.min(100, +(barVol?.value || 80)));
        scWidget.setVolume(vol);

        scWidget.getCurrentSound((s) => { scUpdateTitle(s); scUpdateThumb(s); });
        scWidget.getDuration((d) => { scDuration = d || 0; scUpdateTime(0, scDuration); });

        scWidget.bind(window.SC.Widget.Events.PLAY, () => {
          scWidget.getCurrentSound((s) => { scUpdateTitle(s); scUpdateThumb(s); });
        });
        scWidget.bind(window.SC.Widget.Events.PLAY_PROGRESS, (e) => {
          scDuration = Math.max(scDuration, e?.duration || scDuration || 0);
          const cur = e.currentPosition || 0;
          const rel = e.relativePosition || (scDuration ? cur / scDuration : 0);
          scUpdateTime(cur, scDuration); scUpdateProgress(rel);
        });
        scWidget.bind(window.SC.Widget.Events.ERROR, (err)=> console.error("SC widget error:", err));
        resolve(scWidget);
      });
    });
  }
  async function ensureScReadyAndPlay(){
    if (!SC_ENABLED || scLoading) return;
    scLoading = true;
    try{
      await loadScApiOnce();
      await mountScIframeOnce();
      const w = await initScWidgetOnce();
      if (w) w.play();
    }catch(e){
      console.warn("SC lazy-load failed:", e);
    }finally{ scLoading = false; }
  }
  function bindBarControls(){
    const pPrev = document.getElementById("barPrev");
    const pPlay = document.getElementById("barPlay");
    const pPause= document.getElementById("barPause");
    const pNext = document.getElementById("barNext");
    const vol   = document.getElementById("barVol");
    const mute  = document.getElementById("barMute");
    const seek  = document.getElementById("scSeek");
    if (pPlay)  pPlay.addEventListener('click', () => ensureScReadyAndPlay());
    if (pPause) pPause.addEventListener('click', () => scReady && scWidget && scWidget.pause());
    if (pPrev)  pPrev.addEventListener('click', () => scReady ? (scWidget && scWidget.prev()) : ensureScReadyAndPlay());
    if (pNext)  pNext.addEventListener('click', () => scReady ? (scWidget && scWidget.next()) : ensureScReadyAndPlay());
    if (vol) vol.addEventListener('input', e =>{
      const v = Math.min(100, Math.max(0, +e.target.value || 75));
      if (scReady && scWidget) scWidget.setVolume(v);
    });
    if (mute) mute.addEventListener('click', ()=>{
      if (!scReady || !scWidget) return;
      scWidget.getVolume(v=>{
        const newV = v > 0 ? 0 : (document.getElementById('barVol')?.value|0) || 75;
        scWidget.setVolume(newV);
      });
    });
    if (seek){
      const doSeek = (px) => {
        if (!scReady || !scWidget || !scDuration) return;
        const rect = seek.getBoundingClientRect();
        const rel = Math.min(1, Math.max(0, (px - rect.left) / rect.width ));
        scWidget.seekTo(rel * scDuration);
      };
      seek.addEventListener("click", e => doSeek(e.clientX));
      seek.addEventListener("keydown", e=>{
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight'){
          e.preventDefault();
          const cur = parseFloat((document.getElementById('scSeekFill')?.style.width || "0").replace("%",""))/100;
          const step = 0.02;
          const rel = Math.min(1, Math.max(0, cur + (e.key==='ArrowRight'? step : -step)));
          if (scReady && scWidget && scDuration) scWidget.seekTo(rel * scDuration);
        }
      });
    }
  }


 /* ========= BOOT ========= */
createScene();

(async function boot(){
  try{
    await document.fonts?.load?.('400 16px Poppins');
    await document.fonts?.load?.('600 16px Poppins');
  }catch(e){}
  applyFixedLayout();
  bindBarControls?.();          // pokud máš definované
  resetCamera({animate:false});
  startShootingStars();         // <<< jednou za čas jedna čára nad "nebem"
})();

/* ========= Render loop ========= */
engine.runRenderLoop(()=>{
  if (!scene) return;
  // Kamera uvnitř místnosti
  constrainTarget?.();
  constrainCameraRadius?.();

  scene.render();

  // AutoScale
  if (AutoScale.enabled){
    const now = performance.now();
    AutoScale.accMs += engine.getDeltaTime();
    AutoScale.frames++;
    if (now - AutoScale.lastEval > AutoScale.windowMs && now > AutoScale.warmupMs){
      const avgMs = AutoScale.accMs / AutoScale.frames;
      let changed = false;
      if (avgMs > AutoScale.lowFpsMs && currentScaleLevel < AutoScale.maxLevel){
        currentScaleLevel = Math.min(AutoScale.maxLevel, currentScaleLevel + AutoScale.step);
        changed = true;
      } else if (avgMs < AutoScale.highFpsMs && currentScaleLevel > AutoScale.minLevel){
        currentScaleLevel = Math.max(AutoScale.minLevel, currentScaleLevel - AutoScale.step);
        changed = true;
      }
      if (changed){
        applyHardwareScale(currentScaleLevel);
        if (glow){
          const base = IS_MOBILE ? 36 : 96;
          glow.blurKernelSize = Math.round( base * (0.9 + 0.2*(1 - (currentScaleLevel-0.33)/(1-0.33))) );
        }
      }
      AutoScale.accMs = 0; AutoScale.frames = 0; AutoScale.lastEval = now;
    }
  }
});

/* ========= Resize & UI ========= */
function handleResize(){ applyHardwareScale(); engine.resize(true); }
window.addEventListener("resize", handleResize, { passive:true });
window.addEventListener("orientationchange", handleResize);
document.addEventListener('gesturestart', e => { if (IS_IOS) { e.preventDefault(); } }, { passive:false });

/* UI: reset + fullscreen */
const resetCamIcon = document.getElementById('resetCamIcon');
if (resetCamIcon){
  resetCamIcon.addEventListener('dragstart', e => e.preventDefault());
  resetCamIcon.addEventListener('click', () => resetCamera({animate:true}));
  resetCamIcon.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); resetCamera({animate:true}); } });
}
window.addEventListener('keydown', (e)=>{ if (e.key.toLowerCase() === 'r') resetCamera({animate:true}); });

const fullscreenIcon = document.getElementById('fullscreenIcon');
if (fullscreenIcon){
  fullscreenIcon.addEventListener('dragstart', e => e.preventDefault());
  fullscreenIcon.addEventListener('click', toggleFullscreen);
  fullscreenIcon.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' || e.key === ' '){ e.preventDefault(); toggleFullscreen(); } });
  document.addEventListener('fullscreenchange', syncFsButton);
  document.addEventListener('webkitfullscreenchange', syncFsButton);
}
</script>
