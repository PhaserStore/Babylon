<!doctype html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Virtual Gallery ‚Äî LED ¬∑ Layout ¬∑ URL loader</title>

  <style>
    html,body{width:100%;height:100%;margin:0;overflow:hidden;background:#111;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    #renderCanvas{width:100%;height:100%;display:block;touch-action:none}

    /* ===== ADMIN UI ===== */
    #ui{
      position:fixed;top:12px;left:12px;right:12px;z-index:10;
      display:flex;flex-wrap:wrap;gap:8px;align-items:center;
      background:rgba(15,15,18,.65);border:1px solid rgba(255,255,255,.15);
      border-radius:10px;padding:10px 12px;color:#fff;backdrop-filter:blur(6px)
    }
    .group{display:flex;gap:8px;align-items:center;background:rgba(40,40,44,.5);padding:8px 10px;border-radius:8px}
    input,button,textarea{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,.2);background:#3a3a3a;color:#fff}
    button:hover{background:#575757}
    textarea{min-width:320px;min-height:80px}
    #hint{flex-basis:100%;font-size:12px;color:#ccc}
    body.view #ui{display:none}
    label{display:flex;gap:6px;align-items:center}

    /* Publish jen v ADMIN m√≥du */
    #publishBtn{
      position:fixed;top:12px;right:12px;z-index:9999;padding:8px 12px;
      display:none;
    }
    body.admin #publishBtn{ display:inline-flex; }
  </style>

  <!-- Babylon.js -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>

<body class="view">
  <!-- Publish to GitHub Issue (jen v ADMIN m√≥du) -->
  <button id="publishBtn" title="Publikovat JSON do GitHub Issue">Publish to GitHub</button>

  <!-- ===== UI (ADMIN ‚Äì zobraz√≠ se a≈æ po kl√°vese A) ===== -->
  <div id="ui">
    <div class="group">
      <label>URL <input id="imgUrl" size="38" placeholder="https://... (.avif/.jpg/.png/.webp)"></label>
      <button id="btnLoad">Naƒç√≠st do vybran√©ho r√°mu</button>
      <button id="btnDemo">Naƒç√≠st DEMO</button>
    </div>

    <div class="group">
      <label>N√°zev <input id="title" placeholder="N√°zev d√≠la" size="16"></label>
      <label>Skryt√° URL <input id="link" placeholder="https://..." size="18"></label>
      <button id="btnPlacard">Aktualizovat cedulku</button>
    </div>

    <div class="group">
      <button id="btnResetCam">üé• Reset kamery</button>
      <button id="btnMore">‚ûï P≈ôidat dal≈°√≠ stƒõny</button>
    </div>

    <div id="hint">A = ADMIN ¬∑ V = VIEW ¬∑ Klik na r√°m = v√Ωbƒõr (modr√Ω lem). Dvojklik = p≈ôibl√≠≈æen√≠. Klik na cedulku = skryt√° URL.</div>
  </div>

  <!-- ===== Canvas ===== -->
  <canvas id="renderCanvas"></canvas>

  <!-- ===== Hlavn√≠ skript (inline) ===== -->
  <script>
  "use strict";

  /* ================ MODE ================ */
  const MODE = { ADMIN: "admin", VIEW: "view" };
  let mode = MODE.VIEW;

  const $ = (id)=>document.getElementById(id);
  const imgUrlEl=$("imgUrl"), titleEl=$("title"), linkEl=$("link"), hintEl=$("hint");

  function isTyping(e){ const t=e.target?.tagName?.toLowerCase(); return t==="input"||t==="textarea"||t==="select"||e.target?.isContentEditable; }
  function hint(msg){ if(hintEl) hintEl.textContent=msg; }
  function setMode(m){
    mode = m;
    document.body.classList.toggle('view', m === MODE.VIEW);
    document.body.classList.toggle('admin', m === MODE.ADMIN);
    if (m === MODE.VIEW) clearSelection();
    hint(m === MODE.ADMIN ? "ADMIN m√≥d: editace povolena" : "VIEW m√≥d: ƒçist√° v√Ωstava");
  }
  window.addEventListener('keydown',(e)=>{ if(isTyping(e)) return; const k=e.key.toLowerCase(); if(k==='a') setMode(MODE.ADMIN); if(k==='v') setMode(MODE.VIEW); });

  /* ============== ENGINE / SCENE / CAMERA ============== */
  const canvas = $("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:true, stencil:true, antialias:true });
  try{
    const dpr = window.devicePixelRatio || 1;
    if (dpr > 2) engine.setHardwareScalingLevel(2 / dpr); // mobiln√≠ Safari stabilita
  }catch{}

  let scene, camera, glow, hl;

  const ROOM = { W: 16, D: 30, H: 5.6 };
  const MIN_RADIUS = 1.6, MAX_RADIUS = 40;

  function createScene(){
    scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.06,0.06,0.06,1);

    camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/2.25, 11.5, new BABYLON.Vector3(0, ROOM.H*0.48, 0), scene);
    camera.attachControl(canvas, true);
    camera.lowerBetaLimit = 0.1;
    camera.upperBetaLimit = Math.PI - 0.1;
    camera.lowerRadiusLimit = MIN_RADIUS;
    camera.upperRadiusLimit = MAX_RADIUS;
    camera.wheelDeltaPercentage = 0.02;
    camera.pinchDeltaPercentage = 0.02;
    camera.inertia = 0.85;

    new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);

    glow = new BABYLON.GlowLayer("gl", scene, { blurKernelSize:48 });
    glow.intensity = 0.35;      // jemnƒõj≈°√≠ glow, aby ‚Äûnep≈ôepaloval‚Äú

    hl = new BABYLON.HighlightLayer("hl", scene);

    buildRoom();
    buildLED();
    buildLogoSimple();          // logo bez glow duplik√°t≈Ø (ƒçist√© a ostr√©)

    setupPicking();
    setupDoubleClickZoom();
    return scene;
  }

  /* ====================== ROOM + LED ====================== */
  function unlit(hex){ const m=new BABYLON.StandardMaterial("m",scene); m.diffuseColor=BABYLON.Color3.FromHexString(hex); m.disableLighting=true; return m; }
  function unlitTex(tex){ const m=new BABYLON.StandardMaterial("mt",scene); m.disableLighting=true; m.diffuseTexture=tex; m.backFaceCulling=true; return m; }

  function buildRoom(){
    BABYLON.MeshBuilder.CreateGround("floor",{width:ROOM.W, height:ROOM.D},scene).material = unlit("#141414");
    const back    = BABYLON.MeshBuilder.CreatePlane("back",{width:ROOM.W, height:ROOM.H},scene);
    back.position.set(0, ROOM.H/2, -ROOM.D/2 + 0.01); back.material = unlit("#262626");
    const front   = BABYLON.MeshBuilder.CreatePlane("front",{width:ROOM.W, height:ROOM.H},scene);
    front.position.set(0, ROOM.H/2,  ROOM.D/2 - 0.01); front.rotation.y = Math.PI; front.material = unlit("#262626");
    const ceiling = BABYLON.MeshBuilder.CreateGround("ceiling",{width:ROOM.W, height:ROOM.D},scene);
    ceiling.position.y = ROOM.H; ceiling.rotation.x = Math.PI; ceiling.material = unlit("#0f0f10");

    const left = BABYLON.MeshBuilder.CreatePlane("leftWall",{width:ROOM.D, height:ROOM.H},scene);
    left.position.set(-ROOM.W/2 + 0.01, ROOM.H/2, 0); left.rotation.y = -Math.PI/2; left.material = unlit("#242424");

    const right = BABYLON.MeshBuilder.CreatePlane("rightWall",{width:ROOM.D, height:ROOM.H},scene);
    right.position.set( ROOM.W/2 - 0.01, ROOM.H/2, 0); right.rotation.y =  Math.PI/2; right.material = unlit("#242424");
  }

  function buildLED(){
    const n=new BABYLON.TransformNode("led",scene);
    const t=0.02, inw=0.12;
    const xL=-ROOM.W/2+inw, xR=ROOM.W/2-inw;
    const zF=ROOM.D/2-inw,  zB=-ROOM.D/2+inw;
    const y0=0.05, y1=ROOM.H-0.05;
    const mat=new BABYLON.StandardMaterial("ledMat",scene); mat.emissiveColor=BABYLON.Color3.FromHexString("#ffbdf6"); mat.disableLighting=true;

    const seg=(a,b)=>{ const d=BABYLON.Vector3.Distance(a,b); const m=BABYLON.MeshBuilder.CreateBox("ledSeg",{width:t,height:t,depth:d},scene); m.position=BABYLON.Vector3.Center(a,b); m.lookAt(b); m.material=mat; m.isPickable=false; m.parent=n; glow.addIncludedOnlyMesh(m); };

    [[xL,y0,zF,xR,y0,zF],[xR,y0,zF,xR,y0,zB],[xR,y0,zB,xL,y0,zB],[xL,y0,zB,xL,y0,zF],
     [xL,y1,zF,xR,y1,zF],[xR,y1,zF,xR,y1,zB],[xR,y1,zB,xL,y1,zB],[xL,y1,zB,xL,y1,zF]
    ].forEach(([ax,ay,az,bx,by,bz])=>seg(new BABYLON.Vector3(ax,ay,az),new BABYLON.Vector3(bx,by,bz)));
    [[xL,zF],[xR,zF],[xR,zB],[xL,zB]].forEach(([x,z])=>seg(new BABYLON.Vector3(x,y0,z), new BABYLON.Vector3(x,y1,z)));
  }

  /* ====================== LOGO (ostr√Ω 1 plane) ====================== */
  const GALLERY_LOGO_SVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 941.43 272.86" preserveAspectRatio="xMidYMid meet">
  <defs><style>.a{fill:#daff3e}</style></defs>
  <g>
    <path class="a" d="M317.06,103.94h-76.71c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h76.71c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
    <path class="a" d="M596.11,104.5h-75.2c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h75.2c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
  </g>
</svg>`;
  function buildLogoSimple(){
    const img = new Image();
    img.src = "data:image/svg+xml;utf8," + encodeURIComponent(GALLERY_LOGO_SVG);
    img.onload = () => {
      const SIZE = 1024;
      const dt  = new BABYLON.DynamicTexture("logoDT",{width:SIZE,height:SIZE},scene,true);
      const ctx = dt.getContext();
      const maxW = SIZE * 0.65;
      const w = maxW, h = Math.round(maxW / (941.43/272.86));
      const x = Math.round((SIZE - w)/2), y = Math.round((SIZE - h)/2);
      ctx.clearRect(0,0,SIZE,SIZE); ctx.drawImage(img, x, y, w, h); dt.update();

      const mat = unlitTex(dt);
      const plane = BABYLON.MeshBuilder.CreatePlane("logo", { width: ROOM.W*0.42, height: 2.2, sideOrientation:BABYLON.Mesh.FRONTSIDE }, scene);
      plane.position.set(0, ROOM.H*0.72, -ROOM.D/2 + 0.06); // mal√Ω offset dop≈ôedu
      plane.rotation.y = 0;
      plane.material = mat;
    };
  }

  /* ====================== FRAMES ====================== */
  const framesByWall = { back: [], front: [], left: [], right: [] };
  const FRAME_SIZE = { W: 1.2, H: 1.2 };
  const FRAME_BOX_BORDER = 0.08;
  const SAFE = 0.8, CORNER_SAFE = 0.6;
  const FRAME_OFFSET = 0.06; // vƒõt≈°√≠ odsazen√≠ od zdi (bez z-fightingu)

  function lightGrayPlaceholderMat(text){
    const dt=new BABYLON.DynamicTexture("ph2",{width:512,height:512},scene,true);
    const c=dt.getContext();
    c.fillStyle="#cbcbcb"; c.fillRect(0,0,512,512);
    c.fillStyle="#222";    c.font="bold 32px system-ui"; c.textAlign="center"; c.textBaseline="middle";
    c.fillText(text,256,256);
    dt.update(); return unlitTex(dt);
  }
  function drawPlacard(plac,data){
    const dt=new BABYLON.DynamicTexture("pl",{width:1024,height:256},scene,true);
    const c=dt.getContext();
    c.fillStyle="#222"; c.fillRect(0,0,1024,256);
    c.fillStyle="#e6e6e6"; c.font="bold 56px system-ui"; c.textAlign="center"; c.textBaseline="middle";
    c.fillText(data.title||"(bez n√°zvu)",512,128);
    dt.update(); plac.material=unlitTex(dt);
  }

  function inwardForward(rotY){ return new BABYLON.Vector3(Math.sin(rotY), 0, Math.cos(rotY)); }

  function addFrame(pos, rotY=0, wall='back'){
    const box = BABYLON.MeshBuilder.CreateBox("frameBox",{width:FRAME_SIZE.W+FRAME_BOX_BORDER,height:FRAME_SIZE.H+FRAME_BOX_BORDER,depth:0.05},scene);
    box.position = pos.clone(); box.rotation.y = rotY;
    box.material = unlit("#383838"); box.isPickable = true;

    const f = BABYLON.MeshBuilder.CreatePlane("frame",{width:FRAME_SIZE.W,height:FRAME_SIZE.H, sideOrientation:BABYLON.Mesh.FRONTSIDE},scene);
    const inward = inwardForward(rotY);
    f.position = pos.add(inward.scale(FRAME_OFFSET));
    f.rotation.y = rotY; f.isPickable = true;
    f.material  = lightGrayPlaceholderMat("KLIKNOUT ‚Üí VYBRAT");

    const plac = BABYLON.MeshBuilder.CreatePlane("plac",{width:FRAME_SIZE.W,height:0.22, sideOrientation:BABYLON.Mesh.FRONTSIDE},scene);
    plac.position = f.position.add(new BABYLON.Vector3(0, -FRAME_SIZE.H*0.83, 0.01));
    plac.rotation.y = rotY; plac.isPickable = true;

    const data = { title: "(bez n√°zvu)", url: "", src: "", srcData: "" };
    drawPlacard(plac, data);

    return { frame:f, box, placard:plac, data, wall, rotY };
  }

  function distributeCenters(min, max, count, frameW){
    if (count <= 1) return [ (min+max)/2 ];
    const span = max - min;
    const totalFramesWidth = count * frameW;
    let gap = (span - totalFramesWidth) / (count - 1);
    const MIN_GAP = 0.05;
    if (gap < MIN_GAP) gap = Math.max(gap, MIN_GAP);
    const centers = [];
    let x = min + frameW/2;
    for (let i=0;i<count;i++){ centers.push(x); x += frameW + gap; }
    return centers;
  }

  function createFramesBackWall(count=7){
    const centerY = ROOM.H * 0.55;
    const rotY = 0; // back wall -> front face do +Z
    const length = ROOM.W;
    const min = -length/2 + SAFE + CORNER_SAFE;
    const max =  length/2 - SAFE - CORNER_SAFE;
    framesByWall.back.forEach(it=>{ it.frame.dispose(); it.box.dispose(); it.placard.dispose(); });
    framesByWall.back = [];
    const centers = distributeCenters(min,max,count,FRAME_SIZE.W);
    centers.forEach(x=>{
      const pos = new BABYLON.Vector3(x, centerY, -ROOM.D/2 + 0.01);
      framesByWall.back.push( addFrame(pos, rotY, 'back') );
    });
  }

  /* ====================== PICKING / ZOOM ====================== */
  let selected = null;
  function clearSelection(){ if(!selected) return; selected.box.renderOutline=false; hl.removeAllMeshes(); selected=null; }
  function selectFrame(it){
    if(mode!==MODE.ADMIN) return;
    clearSelection();
    selected=it;
    it.box.outlineColor = new BABYLON.Color3(0.4,0.8,1.0);
    it.box.outlineWidth = 0.04;
    it.box.renderOutline = true;
    hl.addMesh(it.box, new BABYLON.Color3(0.4,0.8,1.0));
    hint("Vybr√°n r√°m.");
  }
  function setupPicking(){
    scene.onPointerObservable.add((pi)=>{
      if (pi.type !== BABYLON.PointerEventTypes.POINTERPICK) return;
      if (!pi.pickInfo?.hit) return;
      const mesh = pi.pickInfo.pickedMesh;
      for(const it of framesByWall.back){
        if (mesh === it.placard && it.data.url){ window.open(it.data.url,"_blank","noopener"); return; }
        if (mode === MODE.ADMIN && (mesh===it.frame||mesh===it.box)){ selectFrame(it); return; }
      }
    }, BABYLON.PointerEventTypes.POINTERPICK);
  }
  function setupDoubleClickZoom(){
    canvas.addEventListener("dblclick", ()=>{
      const pick=scene.pick(scene.pointerX,scene.pointerY);
      if(!pick?.hit) return;
      camera.target=pick.pickedPoint.clone();
      camera.radius=Math.max(MIN_RADIUS, camera.radius*0.65);
    });
  }

  /* ====================== IMAGE LOADING ====================== */
  function drawFitted(ctx,bmp,frameW,frameH){
    const targetR=frameW/frameH, r=bmp.width/bmp.height; let dw=1024,dh=1024,dx=0,dy=0;
    if(r>targetR){ dh=1024; dw=Math.round(dh*r); dx=Math.round((1024-dw)/2);} else{ dw=1024; dh=Math.round(dw/r); dy=Math.round((1024-dh)/2);}
    ctx.fillStyle="#000"; ctx.fillRect(0,0,1024,1024);
    ctx.drawImage(bmp,0,0,bmp.width,bmp.height,dx,dy,dw,dh);
  }
  function blobToImg(blob){ return new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=()=>rej(new Error("IMG decode failed")); img.src=URL.createObjectURL(blob); }); }
  function dataUrlToImg(dataUrl){ return new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=()=>rej(new Error("DataURL decode failed")); img.src=dataUrl; }); }
  function dynamicTextureToDataUrl(dt){ try{ const c = dt.getContext().canvas; return c.toDataURL("image/png"); }catch(e){ return ""; } }

  async function loadImageUrlIntoTexture(url, item){
    try{
      const resp=await fetch(url,{mode:"cors",cache:"no-store"}); if(!resp.ok) throw new Error("HTTP "+resp.status);
      const ct=resp.headers.get("content-type")||""; if(!ct.startsWith("image/")) throw new Error("NOT_IMAGE");
      const blob=await resp.blob();
      const bmp=await blobToImg(blob);
      const dt=new BABYLON.DynamicTexture("imgDT",{width:1024,height:1024},scene,true);
      const ctx=dt.getContext(); drawFitted(ctx,bmp,FRAME_SIZE.W,FRAME_SIZE.H); dt.update();
      item.frame.material = unlitTex(dt);
      item.data.src = url;
      const snap = dynamicTextureToDataUrl(dt);
      if (snap) item.data.srcData = snap;
      autosave();
      hint("Obr√°zek naƒçten ‚úî");
    }catch(e){ console.warn("Load image failed:", e); alert("Nelze st√°hnout obr√°zek (CORS / nep≈ô√≠m√© URL)."); }
  }
  async function loadSVGOrDataIntoTexture(dataUrl, item){
    try{
      const bmp = await dataUrlToImg(dataUrl);
      const dt=new BABYLON.DynamicTexture("imgDT",{width:1024,height:1024},scene,true);
      const ctx=dt.getContext(); drawFitted(ctx,bmp,FRAME_SIZE.W,FRAME_SIZE.H); dt.update();
      item.frame.material = unlitTex(dt);
      item.data.src = dataUrl;
      const snap = dynamicTextureToDataUrl(dt);
      if (snap) item.data.srcData = snap;
      autosave();
      hint("Obr√°zek/SVG naƒçten ‚úî");
    }catch(e){ console.warn("DataURL/SVG decode failed", e); alert("Nelze zpracovat obrazov√° data."); }
  }
  async function loadIntoFrameSmart(inputText, item){
    if(!inputText){ alert("Zadej URL / data:image/... / <svg>‚Ä¶</svg>"); return; }
    const s=inputText.trim();
    if(s.startsWith("<svg")) return loadSVGOrDataIntoTexture("data:image/svg+xml;utf8,"+encodeURIComponent(s),item);
    if(s.startsWith("data:image/")) return loadSVGOrDataIntoTexture(s,item);
    return loadImageUrlIntoTexture(s,item);
  }

  /* ====================== DEMO DATA + AUTOSAVE ====================== */
  const DATA = {
    back: [
      { img:"./assets/one.jpg",   label:"Back A", href:"https://example.com/a" },
      { img:"./assets/two.jpg",   label:"Back B", href:"https://example.com/b" },
      { img:"./assets/three.jpg", label:"Back C", href:"https://example.com/c" },
      { img:"./assets/one.jpg",   label:"Back D", href:"https://example.com/d" },
      { img:"./assets/two.jpg",   label:"Back E", href:"https://example.com/e" },
      { img:"./assets/three.jpg", label:"Back F", href:"https://example.com/f" },
      { img:"./assets/one.jpg",   label:"Back G", href:"https://example.com/g" }
    ]
  };

  function assignDataBackWall(data){
    const arr = framesByWall.back;
    const items = (data && data.back) ? data.back : [];
    const n = Math.min(items.length, arr.length);
    for (let i=0;i<n;i++){
      const it = arr[i], d = items[i];
      if (d.img) {
        const img = new Image(); img.crossOrigin = "anonymous";
        img.onload = ()=>{
          const dt=new BABYLON.DynamicTexture("imgDT"+Math.random(),{width:1024,height:1024},scene,true);
          const ctx=dt.getContext(); drawFitted(ctx,img,FRAME_SIZE.W,FRAME_SIZE.H); dt.update();
          it.frame.material = unlitTex(dt);
          it.data.src = d.img;
          const snap = dynamicTextureToDataUrl(dt); if (snap) it.data.srcData = snap;
          autosave();
        };
        img.onerror = ()=> loadImageUrlIntoTexture(d.img, it);
        img.src = d.img;
      }
      it.data.title = d.label || "(bez n√°zvu)";
      it.data.url   = d.href || "";
      drawPlacard(it.placard, it.data);
    }
  }

  function autosave(){
    try{
      const out = { back: [] };
      out.back = (framesByWall.back || []).map(it => ({
        img:     it.data.src || '',
        imgData: it.data.srcData || '',
        label:   it.data.title || '',
        href:    it.data.url || ''
      }));
      localStorage.setItem('draftGalleryJson', JSON.stringify(out));
    }catch(e){}
  }

  /* ====================== UI ====================== */
  $("btnLoad").addEventListener("click", ()=>{
    const it = selected || framesByWall.back[0];
    if(!it){ alert("Neexistuje ≈æ√°dn√Ω r√°m."); return; }
    const input = imgUrlEl.value.trim();
    loadIntoFrameSmart(input, it);
  });
  $("btnPlacard").addEventListener("click", ()=>{
    const it=selected || framesByWall.back[0];
    if(!it){ alert("Neexistuje ≈æ√°dn√Ω r√°m."); return; }
    it.data.title = (titleEl?.value || "(bez n√°zvu)").trim() || "(bez n√°zvu)";
    it.data.url   = (linkEl?.value  || "").trim();
    drawPlacard(it.placard, it.data);
    autosave();
    hint("Cedulka aktualizov√°na.");
  });
  $("btnResetCam").addEventListener("click", ()=>{
    camera.target.set(0, ROOM.H*0.48, 0);
    camera.radius=11.5;
  });
  $("btnDemo").addEventListener("click", ()=>{
    assignDataBackWall(DATA);
    autosave();
    hint("DEMO data nahr√°na.");
  });
  $("btnMore").addEventListener("click", ()=>{
    alert("A≈æ potvrd√≠≈°, ≈æe zadn√≠ stƒõna je OK, roz≈°√≠≈ô√≠m na 7/7/13/13 + roz√≠ch SAFE z√≥ny.");
  });

  /* ====================== Publish (ADMIN only) ====================== */
  $("publishBtn").addEventListener('click', () => {
    if (document.body.classList.contains('view')) { alert('Publish je dostupn√Ω jen v ADMIN m√≥du (kl√°vesa A).'); return; }
    try {
      const out = { back: (framesByWall.back||[]).map(it => ({
        img: it.data.src||'', imgData: it.data.srcData||'', label: it.data.title||'', href: it.data.url||''
      }))};
      const minified = JSON.stringify(out);
      localStorage.setItem('draftGalleryJson', minified);
      const title = encodeURIComponent('Update gallery');
      const body  = encodeURIComponent(minified);
      const url   = `https://github.com/PhaserStore/Babylon/issues/new?title=${title}&body=${body}`;
      window.open(url, '_blank', 'noopener');
    } catch (e) {
      console.error(e);
      alert('Export selhal ‚Äì zkontroluj, ≈æe data jsou validn√≠.');
    }
  });

  /* ====================== BOOT ====================== */
  createScene();
  engine.runRenderLoop(()=> scene.render());
  window.addEventListener("resize", ()=> engine.resize());
  setMode(MODE.VIEW);

  createFramesBackWall(7);     // jen zadn√≠ stƒõna ‚Üí hned uvid√≠≈° r√°my
  assignDataBackWall(DATA);    // demo obr√°zky (pokud m√°≈° ./assets/...)
  </script>
</body>
</html>
``
