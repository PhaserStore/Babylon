<!doctype html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Virtual Gallery ‚Äî LED ¬∑ Layout ¬∑ Publish</title>

  <!-- ‚úÖ Poppins font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />

  <style>
    :root{
      --ui-bg: rgba(15,15,18,.65);
      --ui-brd: rgba(255,255,255,.15);
      --ui-chip: rgba(40,40,44,.5);
      --txt:#fff; --txt-dim:#ccc;
      --touch:44px;
      --safe-top: env(safe-area-inset-top);
      --safe-right: env(safe-area-inset-right);
      --safe-bottom: env(safe-area-inset-bottom);
      --safe-left: env(safe-area-inset-left);
    }
    html,body{
      width:100%;height:100%;margin:0;overflow:hidden;background:#111;
      font-family:'Poppins',system-ui,Segoe UI,Roboto,Arial,sans-serif;color:var(--txt);
    }
    #renderCanvas{
      position:fixed;inset:0;display:block;touch-action:none;width:100vw;height:100vh;
      will-change: transform; transform: translateZ(0);
    }
/* === VIEW: full-width bottom bar === */
#scBar{
  position:fixed; left:0; right:0; bottom:0;
  height:54px; background:#1a1a1a;
  border-top:1px solid rgba(255,255,255,.15);
  display:flex; align-items:center; padding:0 14px; gap:20px;
  z-index:50; font-size:13px; color:#eee; font-family:'Poppins', sans-serif;
}
body.admin #scBar{ display:none; }   /* schovat v ADMIN */
body.view  #scBar{ display:flex; }   /* zobrazit ve VIEW */

#scBar button{
  width:34px; height:34px; border-radius:8px;
  border:1px solid rgba(255,255,255,.15);
  background:#2b2b2b; color:#fff; cursor:pointer;
}
#scBar button:hover{ background:#3a3a3a; }

.sc-left{ display:flex; gap:6px; align-items:center; }

/* progress bar */
.sc-center{
  flex:1; display:flex; align-items:center; gap:10px; user-select:none;
}
#scSeek{
  flex:1; height:6px; background:#555; border-radius:4px; position:relative; cursor:pointer;
}
#scSeekFill{
  position:absolute; left:0; top:0; bottom:0; width:0%;
  background:#ff6a00; border-radius:4px;
}

.sc-right{
  display:flex; align-items:center; gap:12px; min-width:260px;
}
#scThumb{ width:34px; height:34px; border-radius:6px; object-fit:cover; }
#barVol{ width:80px; }
    /* ===== ADMIN UI ===== */
    #ui{
      position:fixed;left:12px;right:12px;top:calc(12px + var(--safe-top));z-index:10;
      display:flex;flex-wrap:wrap;gap:8px;align-items:center;
      background:var(--ui-bg);border:1px solid var(--ui-brd);
      border-radius:12px;padding:10px 12px;color:#fff;backdrop-filter:blur(6px);
      -webkit-backdrop-filter: blur(6px);
      overflow:auto; scrollbar-width:thin; max-height:40vh;
    }
    @media (max-width: 900px){
      #ui{flex-wrap:nowrap;overflow:auto;white-space:nowrap;}
      #ui::-webkit-scrollbar{height:6px}
    }
    .group{display:flex;gap:8px;align-items:center;background:var(--ui-chip);padding:8px 10px;border-radius:10px}
    input,button{padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.2);background:#3a3a3a;color:#fff;min-height:36px}
    input[type="number"]{width:80px}
    input[type="color"]{padding:0 4px;height:36px;min-width:44px;border-radius:8px;background:#3a3a3a}
    button{cursor:pointer} button:hover{background:#575757}
    label{display:flex;gap:6px;align-items:center}
    #hint{flex-basis:100%;font-size:12px;color:var(--txt-dim);white-space:normal}

    /* VIEW m√≥d = ƒçist√° v√Ωstava (UI nevidƒõt) */
    body.view #ui{display:none}

    /* Publish btn ‚Äî respekt safe-area */
    #publishBtn{
      position:fixed;top:calc(12px + var(--safe-top));right:calc(12px + var(--safe-right));
      z-index:9999;padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.25);
      background:#212121;color:#fff
    }
    body.view #publishBtn{display:none}

    /* === SoundCloud panel (ADMIN only) === */
    #scWrap{
      position:fixed; z-index:12; left:12px; bottom:12px; width:min(420px, 92vw);
      background:var(--ui-bg); border:1px solid var(--ui-brd);
      border-radius:12px; padding:8px; backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
      display:none;
    }
    #scWrap .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    #scWrap button, #scWrap input[type="range"]{
      padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.2);
      background:#3a3a3a; color:#fff; min-height:36px; cursor:pointer;
    }
    #scWrap button:hover{ background:#575757 }
    #scWrap .title{ font-size:12px; color:var(--txt-dim); margin-top:6px; }
    /* Host pro iframe ‚Äì vlo≈æ√≠me a≈æ po prvn√≠m Play (lazy-load) */
    #scIframeHost{ width:100%; height:102px; border-radius:8px; overflow:hidden; background:#222; display:grid; place-items:center; color:#aaa }

    body.admin #scWrap{ display:block }  /* zobrazit jen v admin m√≥du */

    <!-- === VIEW: fullscreen bottom SoundCloud bar === -->
<div id="scBar" aria-label="SoundCloud Bar (View)">
  <div class="sc-left">
    <button id="barPrev" title="Previous">‚èÆ</button>
    <button id="barPlay" title="Play">‚ñ∂Ô∏è</button>
    <button id="barPause" title="Pause">‚è∏</button>
  </div>

  <div class="sc-center">
    <span id="scTimeCur">0:00</span>
    <div id="scSeek" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" tabindex="0">
      <div id="scSeekFill"></div>
    </div>
    <span id="scTimeDur">0:00</span>
  </div>

  <div class="sc-right">
    <button id="barMute" title="Mute/Unmute">üîà</button>
    <input id="barVol" type="range" min="0" max="100" value="75" aria-label="Volume" />
    <img id="scThumb" src="" alt="cover" />
    <span id="scTitle">‚Äì</span>
  </div>
</div>
``

    /* === VIEW: plovouc√≠ fokus/reset ikona (vƒõt≈°√≠) === */
    .focusIcon{
      position:fixed;
      right:calc(12px + var(--safe-right));
      bottom:calc(78px + var(--safe-bottom)); /* nad SC ovladaƒçi (~60px) */
      z-index:10000;
      width:56px; height:56px;               /* m√≠rnƒõ zvƒõt≈°eno */
      cursor:pointer; user-select:none; -webkit-user-drag:none;
      filter: drop-shadow(0 8px 16px rgba(0,0,0,.45));
      opacity:.96; transition: transform .12s ease, opacity .12s ease;
    }
    .focusIcon:hover{ transform:translateY(-1px); opacity:1; }
    body.admin .focusIcon{ display:none; } /* jen ve VIEW */
    body.view  .focusIcon{ display:block; }
  </style>

  <!-- ‚úÖ Babylon.js + GUI -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

  <!-- ‚ö†Ô∏è SoundCloud API NELOADOVAT zde; naƒçteme ho dynamicky a≈æ p≈ôi Play -->
</head>

<!-- Startujeme rovnou ve VIEW m√≥du -->
<body class="view">
  <button id="publishBtn">Publish to GitHub</button>

  <!-- ===== UI ===== -->
  <div id="ui">
    <div class="group">
      <strong>Nastaven√≠:</strong>
      <label>Ochrann√° z√≥na&nbsp;<input id="safeWall" type="number" step="0.05" value="1" /></label>
      <label>Rohov√° rezerva&nbsp;<input id="cornerSafe" type="number" step="0.05" value="1" /></label>
    </div>

    <div class="group">
      <strong>Poƒçty r√°m≈Ø:</strong>
      <label>Front&nbsp;<input id="cntFront" type="number" step="1" min="0" value="4" style="width:70px"></label>
      <label>Back&nbsp;<input  id="cntBack"  type="number" step="1" min="0" value="4" style="width:70px"></label>
      <label>Left&nbsp;<input  id="cntLeft"  type="number" step="1" min="0" value="7" style="width:70px"></label>
      <label>Right&nbsp;<input id="cntRight" type="number" step="1" min="0" value="7" style="width:70px"></label>
    </div>

    <div class="group">
      <strong>R√°m:</strong>
      <label>≈†√≠≈ôka&nbsp;<input  id="frmW"      type="number" step="0.05" value="2"></label>
      <label>V√Ω≈°ka&nbsp;<input  id="frmH"      type="number" step="0.05" value="2"></label>
      <label>Li≈°ta&nbsp;<input  id="frmBorder" type="number" step="0.02" value="0.08"></label>
      <label>Barva&nbsp;<input  id="frmColor"  type="color"  value="#717171"></label>
    </div>

    <div class="group">
      <button id="btnApplyLayout">Pou≈æ√≠t layout</button>
      <button id="btnResetCam">üé• Reset kamery</button>
    </div>

    <div id="hint">A = ADMIN (jen desktop) ¬∑ V = VIEW (jen desktop) ¬∑ Dvojklik/Double‚Äëtap = p≈ôibl√≠≈æen√≠ na bod. Klik na cedulku = skryt√° URL.</div>
  </div>

  <!-- === SoundCloud (ADMIN) ‚Äì widget lazy-load na prvn√≠ Play === -->
  <div id="scWrap" aria-label="SoundCloud Player (Admin)">
    <div class="row" style="justify-content:space-between">
      <strong>üéß Detroit Techno</strong>
      <span class="title" id="scNow">Idle</span>
    </div>
    <!-- Sem se p≈ôi Play vlo≈æ√≠ <iframe id="scIframe"> -->
    <div id="scIframeHost"><small>Player will load on first Play</small></div>

    <div class="row" style="margin-top:8px">
      <button id="scPrev">‚èÆ Prev</button>
      <button id="scPlay">‚ñ∂Ô∏è Play</button>
      <button id="scPause">‚è∏ Pause</button>
      <button id="scNext">‚è≠ Next</button>
      <label style="display:flex;align-items:center;gap:6px;margin-left:auto">
        Vol: <input id="scVol" type="range" min="0" max="100" value="85" />
      </label>
    </div>
  </div>

  <!-- === VIEW ovladaƒçe (bez widgetu) ‚Äì prav√Ω doln√≠ roh === -->
  <div id="scControls" aria-label="Audio Controls (View)">
    <div class="row">
      <button id="vPrev" title="Previous">‚èÆ</button>
      <button id="vPlay" title="Play">‚ñ∂Ô∏è</button>
      <button id="vPause" title="Pause">‚è∏</button>
      <button id="vNext" title="Next">‚è≠</button>
      <label style="display:flex;align-items:center;gap:6px;margin-left:8px">
        Vol: <input id="vVol" type="range" min="0" max="100" value="70" />
      </label>
    </div>
  </div>

  <!-- ===== Canvas ===== -->
  <canvas id="renderCanvas"></canvas>

  <!-- === VIEW: jedna focus ikona (reset kamera) ‚Äì prav√Ω doln√≠ roh nad ovladaƒçi === -->
  <img
    id="resetCamIcon"
    class="focusIcon"
    src="./assets/focus.svg"
    alt="Reset kamery"
    title="Reset kamery"
    role="button"
    tabindex="0"
    aria-label="Reset kamery"
  />

  <!-- ===== Publish (Issue s JSONem) ===== -->
  <script>
    function collectGalleryData() {
      const out = {
        settings: {
          safeWall:   +document.getElementById('safeWall').value   || 1,
          cornerSafe: +document.getElementById('cornerSafe').value || 1,
          frame: {
            width:  +document.getElementById('frmW').value      || 2,
            height: +document.getElementById('frmH').value      || 2,
            border: +document.getElementById('frmBorder').value || 0.2,
            color:  document.getElementById('frmColor').value   || '#717171'
          },
          counts: {
            front: +document.getElementById('cntFront').value || 0,
            back:  +document.getElementById('cntBack').value  || 0,
            left:  +document.getElementById('cntLeft').value  || 0,
            right: +document.getElementById('cntRight').value || 0
          }
        },
        front: [], back: [], left: [], right: []
      };
      if (!window.framesByWall) return out;
      for (const wall of Object.keys(framesByWall)) {
        out[wall] = (framesByWall[wall] || []).map(it => ({
          img:   it.data.src   || '',
          label: it.data.title || '',
          href:  it.data.url   || ''
        })));
      }
      return out;
    }

    function openPrefilledIssueWithJson(jsonString) {
      const title = encodeURIComponent('Update gallery');
      const body  = encodeURIComponent(jsonString);
      const url   = `https://github.com/PhaserStore/Babylon/issues/new?title=${title}&body=${body}`;

      if (url.length > 7500) {
        try {
          navigator.clipboard.writeText(jsonString);
          alert('JSON je moc dlouh√Ω pro URL, zkop√≠roval jsem ho do schr√°nky. Vlo≈æ ho ruƒçnƒõ do tƒõla issue.');
          window.open(`https://github.com/PhaserStore/Babylon/issues/new?title=${title}`, '_blank', 'noopener');
        } catch {
          alert('JSON je moc dlouh√Ω pro URL. Zkop√≠ruj pros√≠m JSON ruƒçnƒõ.');
          window.open(`https://github.com/PhaserStore/Babylon/issues/new?title=${title}`, '_blank', 'noopener');
        }
        return;
      }
      window.open(url, '_blank', 'noopener');
    }

    document.getElementById('publishBtn').addEventListener('click', async () => {
      try {
        const dataObj = (window.lastAppliedGalleryData && Object.keys(window.lastAppliedGalleryData).length)
          ? window.lastAppliedGalleryData
          : collectGalleryData();

        const minified = JSON.stringify(dataObj);
        JSON.parse(minified);
        localStorage.setItem('draftGalleryJson', minified);
        openPrefilledIssueWithJson(minified);
        if (window.hint) hint('Export odesl√°n do GitHub Issue (nov√° z√°lo≈æka).');
      } catch (e) {
        console.warn('Export selhal ‚Äì collectGalleryData()', e);
        if (window.hint) hint('Export selhal ‚Äì viz konzoli.');
      }
    });

    async function loadGallery() {
      try {
        const res = await fetch('./data/gallery.json', { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        window.galleryData = data;
        if (window.assignDataAllWalls) assignDataAllWalls(data);
      } catch (e) {
        console.warn('Nepoda≈ôilo se naƒç√≠st data/gallery.json (mo≈æn√° zat√≠m neexistuje).', e);
      }
    }
    loadGallery();
  </script>

  <!-- ===== Hlavn√≠ skript ===== -->
  <script>
  "use strict";

  const MODE = { ADMIN: "admin", VIEW: "view" };
  let mode = MODE.VIEW; // start ve VIEW
  const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || Math.min(window.innerWidth, window.innerHeight) <= 900;
  const IS_IOS = /iP(ad|hone|od)/.test(navigator.userAgent);

  /* ==== SoundCloud LAZY-LOAD (roz≈°√≠≈ôen√© eventy + metadata) ==== */
  const SC_PLAYLIST_URL = "https://soundcloud.com/vertigo01/sets/detroit-techno";
  let scWidget = null, scReady = false, scLoading = false, scDuration = 0;

  function loadScApiOnce(){
    return new Promise((resolve, reject)=>{
      if (window.SC && window.SC.Widget) return resolve();
      const s = document.createElement('script');
      s.src = "https://w.soundcloud.com/player/api.js";
      s.async = true;
      s.onload = ()=> resolve();
      s.onerror = ()=> reject(new Error("SC API failed to load"));
      document.head.appendChild(s);
    });
  }

  function mountScIframeOnce(){
    return new Promise((resolve)=>{
      const host = document.getElementById('scIframeHost');
      if (!host) return resolve(null);
      let iframe = host.querySelector('iframe');
      if (iframe) return resolve(iframe);

      const url = "https://w.soundcloud.com/player/?"
        + "url=" + encodeURIComponent(SC_PLAYLIST_URL)
        + "&auto_play=false&hide_related=false&show_comments=false"
        + "&show_user=true&show_reposts=false&show_teaser=false&visual=true";

      iframe = document.createElement('iframe');
      iframe.id = "scIframe";
      iframe.title = "SoundCloud Player";
      iframe.allow = "autoplay";
      iframe.setAttribute("scrolling","no");
      iframe.setAttribute("frameborder","no");
      iframe.style.width = "100%";
      iframe.style.height= "102px";
      iframe.style.border = "0";
      iframe.style.borderRadius = "8px";
      iframe.src = url;

      host.innerHTML = "";
      host.appendChild(iframe);
      resolve(iframe);
    });
  }

  function fmtTime(ms){
    const sec = Math.max(0, Math.floor((ms||0)/1000));
    const m = Math.floor(sec/60), s = sec%60;
    return `${m}:${s.toString().padStart(2,'0')}`;
  }

  function updateNowTitle(s){
    const el = document.getElementById('scNow');
    if (!el) return;
    if (!s){ el.textContent = 'Ready'; return; }
    const artist = (s.user && s.user.username) ? s.user.username : (s.publisher_metadata?.artist || 'SoundCloud');
    el.textContent = s.title ? `Now: ${s.title} ‚Äî ${artist}` : 'Playing‚Ä¶';
  }

  function initScWidgetOnce(){
    return new Promise((resolve)=>{
      const iframe = document.getElementById('scIframe');
      if (!iframe || !window.SC || !window.SC.Widget) return resolve(null);
      if (scWidget) return resolve(scWidget);

      scWidget = window.SC.Widget(iframe);

      scWidget.bind(window.SC.Widget.Events.READY, ()=>{
        sc// === NEW BAR UPDATE HELPERS ===
function scUpdateTime(cur, dur){
  const curEl = document.getElementById("scTimeCur");
  const durEl = document.getElementById("scTimeDur");
  if (!curEl || !durEl) return;
  curEl.textContent = fmtTime(cur);
  durEl.textContent = fmtTime(dur);
}
function scUpdateThumb(s){
  const t = document.getElementById("scThumb");
  if (!t) return;
  let art = s?.artwork_url || s?.user?.avatar_url || "";
  if (art) art = art.replace("-large.jpg","-t200x200.jpg");
  t.src = art || "";
}
function scUpdateTitle(s){
  const el = document.getElementById("scTitle");
  if (!el) return;
  if (!s){ el.textContent = "‚Äì"; return; }
  el.textContent = s.title || "Unknown";
}
function scUpdateProgress(rel){
  const fill = document.getElementById("scSeekFill");
  if (!fill) return;
  fill.style.width = (Math.max(0, Math.min(1, rel)) * 100).toFixed(2) + "%";
}
``Ready = true;
        

        // Volume init (admin > view fallback)
        const adminVol = document.getElementById('scVol');
        const viewVol  = document.getElementById('vVol');
        const vol = Math.max(0, Math.min(100, +(adminVol?.value || viewVol?.value || 80)));
        scWidget.setVolume(vol);

        // Init meta + duration
        scWidget.getCurrentSound((s)=> updateNowTitle(s));
        scWidget.getDuration((d)=>{ scDuration = d || 0; });

        // Eventy
        scWidget.bind(window.SC.Widget.Events.PLAY,  ()=>{ scWidget.getCurrentSound((s)=> updateNowTitle(s)); });
        scWidget.bind(window.SC.Widget.Events.PAUSE, ()=>{ /* ponech√°me ticho */ });
        scWidget.bind(window.SC.Widget.Events.FINISH,()=>{ /* auto-next ≈ôe≈°√≠ widget UI */ });

        scWidget.bind(window.SC.Widget.Events.PLAY_PROGRESS, (e)=>{
          scDuration = Math.max(scDuration, e?.duration || 0);
          // M≈Ø≈æe≈° sem doplnit vizu√°l ƒçasu do UI, kdy≈æ bude≈° cht√≠t:
          // hint(`‚è± ${fmtTime(e.currentPosition||0)} / ${fmtTime(scDuration)}`);
        });

        resolve(scWidget);
      });
    });
  }

  async function ensureScReadyAndPlay(){
    if (scLoading) return;
    scLoading = true;
    try{
      await loadScApiOnce();
      await mountScIframeOnce();
      const w = await initScWidgetOnce();
      if (w) w.play(); // v r√°mci u≈æivatelsk√©ho gesta ‚Üí povoleno
    }catch(e){
      console.warn("SC lazy-load failed:", e);
    }finally{
      scLoading = false;
    }
  }

  function bindAdminControls(){
    const prev = document.getElementById('scPrev');
    const next = document.getElementById('scNext');
    const play = document.getElementById('scPlay');
    const pause= document.getElementById('scPause');
    const vol  = document.getElementById('scVol');

    if (play)  play.addEventListener('click',  () => ensureScReadyAndPlay());
    if (pause) pause.addEventListener('click', () => scReady && scWidget && scWidget.pause());
    if (prev)  prev.addEventListener('click',  () => scReady ? scWidget && scWidget.prev() : ensureScReadyAndPlay());
    if (next)  next.addEventListener('click',  () => scReady ? scWidget && scWidget.next() : ensureScReadyAndPlay());
    if (vol)   vol.addEventListener('input',   (e)=>{
      const v = Math.max(0, Math.min(100, +e.target.value || 80));
      if (scReady && scWidget) scWidget.setVolume(v);
    });
  }

  function bindViewControls(){
    const prev = document.getElementById('vPrev');
    const next = document.getElementById('vNext');
    const play = document.getElementById('vPlay');
    const pause= document.getElementById('vPause');
    const vol  = document.getElementById('vVol');

    if (play)  play.addEventListener('click',  () => ensureScReadyAndPlay());
    if (pause) pause.addEventListener('click', () => scReady && scWidget && scWidget.pause());
    if (prev)  prev.addEventListener('click',  () => scReady ? scWidget && scWidget.prev() : ensureScReadyAndPlay());
    if (next)  next.addEventListener('click',  () => scReady ? scWidget && scWidget.next() : ensureScReadyAndPlay());
    if (vol)   vol.addEventListener('input',   (e)=>{
      const v = Math.max(0, Math.min(100, +e.target.value || 70));
      if (scReady && scWidget) scWidget.setVolume(v);
    });
  }
function bindBarControls(){
  const pPrev = document.getElementById("barPrev");
  const pPlay = document.getElementById("barPlay");
  const pPause= document.getElementById("barPause");
  const vol   = document.getElementById("barVol");
  const mute  = document.getElementById("barMute");
  const seek  = document.getElementById("scSeek");

  // Play/Pause/Prev
  if (pPlay)  pPlay.addEventListener('click', () => ensureScReadyAndPlay());
  if (pPause) pPause.addEventListener('click', () => scReady && scWidget && scWidget.pause());
  if (pPrev)  pPrev.addEventListener('click', () => scReady ? (scWidget && scWidget.prev()) : ensureScReadyAndPlay());

  // Volume + mute toggle
  if (vol) vol.addEventListener('input', e =>{
    const v = Math.min(100, Math.max(0, +e.target.value || 75));
    if (scReady && scWidget) scWidget.setVolume(v);
  });
  if (mute) mute.addEventListener('click', ()=>{
    if (!scReady || !scWidget) return;
    scWidget.getVolume(v=>{
      const newV = v > 0 ? 0 : (document.getElementById('barVol')?.value|0) || 75;
      scWidget.setVolume(newV);
    });
  });

  // Seek click
  if (seek){
    const doSeek = (px) => {
      if (!scReady || !scWidget || !scDuration) return;
      const rect = seek.getBoundingClientRect();
      const rel = Math.min(1, Math.max(0, (px - rect.left) / rect.width ));
      scWidget.seekTo(rel * scDuration);
    };
    seek.addEventListener("click", e => doSeek(e.clientX));
    seek.addEventListener("keydown", e=>{
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight'){
        e.preventDefault();
        const cur = parseFloat((document.getElementById('scSeekFill')?.style.width || "0").replace("%",""))/100;
        const step = 0.02;
        const rel = Math.min(1, Math.max(0, cur + (e.key==='ArrowRight'? step : -step)));
        if (scReady && scWidget && scDuration) scWidget.seekTo(rel * scDuration);
      }
    });
  }
}
  // P≈ôedrender font≈Ø
  async function ensurePoppins() {
    if (document?.fonts?.load) {
      try {
        await document.fonts.load('400 16px Poppins');
        await document.fonts.load('600 16px Poppins');
        await document.fonts.ready;
      } catch(e) {}
    }
  }

  // Edge/Safari DPR snapping
  function snapDpr(raw) {
    const v = Math.max(1, Math.min(raw || 1, 3));
    const steps = [1, 1.25, 1.5, 2, 2.5, 3];
    let pick = steps[0], best = Infinity;
    for (const s of steps){ const d = Math.abs(s - v); if (d < best){ best = d; pick = s; } }
    return pick;
  }
  const DPR_RAW = window.devicePixelRatio || 1;
  const DPR = snapDpr(DPR_RAW);

  const $ = (id)=>document.getElementById(id);
  const hintEl = $("hint");
  function hint(msg){ if(hintEl) hintEl.textContent=msg; }
  function isTyping(e){ const t=e.target?.tagName?.toLowerCase(); return t==="input"||t==="textarea"||t==="select"||e.target?.isContentEditable; }

  function setMode(m){
    mode = m;
    document.body.classList.toggle('view', m === MODE.VIEW);
    document.body.classList.toggle('admin', m === MODE.ADMIN);
    hint(m === MODE.ADMIN ? "ADMIN m√≥d: nastaven√≠ povoleno" : "VIEW m√≥d: ƒçist√° v√Ωstava");

    // P≈ôi p≈ôechodu do VIEW pauzneme (u≈æivatel spust√≠ Play ruƒçnƒõ)
    if (m === MODE.VIEW){
      if (scReady && scWidget) scWidget.pause();
    }
  }

  // Kl√°vesov√© p≈ôep√≠n√°n√≠ (desktop)
  window.addEventListener('keydown',(e)=>{
    if (IS_MOBILE) return;
    if (isTyping(e)) return;
    const k=e.key.toLowerCase();
    if(k==='a') setMode(MODE.ADMIN);
    if(k==='v') setMode(MODE.VIEW);
  }, { passive:true });

  // Pomocn√°: nejbli≈æ≈°√≠ power-of-two
  function nearestPOT(n, cap){ 
    const p = Math.pow(2, Math.round(Math.log2(Math.max(2, n))));
    return Math.min(p, cap || p);
  }

  // Textury ‚Äì z√°klad dle za≈ô√≠zen√≠ (fin√°ln√≠ po z√≠sk√°n√≠ GPU cap)
  const TEX_BASE = IS_MOBILE ? 1024 : 2048;
  let TEX_SIZE = Math.round(TEX_BASE * Math.min(DPR, 2));

  const canvas = $("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, {
    preserveDrawingBuffer:false, stencil:false, antialias:true, adaptToDeviceRatio:false,
    powerPreference: "high-performance"
  });
  if (!window.BABYLON) { console.error("Babylon.js se nenaƒçetl."); }

  // GPU limity
  const CAPS = engine.getCaps ? engine.getCaps() : {};
  const MAX_TEX_CAP = Math.max(512, CAPS.maxTextureSize || 2048);
  const MOBILE_TEX_CAP  = Math.min(MAX_TEX_CAP, 1024);
  const DESKTOP_TEX_CAP = Math.min(MAX_TEX_CAP, 4096);
  TEX_SIZE = nearestPOT(Math.min(TEX_SIZE, IS_MOBILE ? MOBILE_TEX_CAP : DESKTOP_TEX_CAP), IS_MOBILE ? MOBILE_TEX_CAP : DESKTOP_TEX_CAP);

  // anisotropie
  const MAX_ANISO = CAPS.maxAnisotropy || 4;

  // HW scale
  const BASE_LEVEL = Math.max(0.33, Math.min(1 / DPR, 1));
  let currentScaleLevel = Math.round(BASE_LEVEL * 100) / 100;
  function applyHardwareScale(levelOverride){
    const lvl = typeof levelOverride === "number" ? levelOverride : currentScaleLevel;
    engine.setHardwareScalingLevel(Math.round(lvl * 100) / 100);
  }
  applyHardwareScale();

  // mobiln√≠ auto-scale (jemn√Ω)
  const AutoScale = {
    enabled: IS_MOBILE,
    windowMs: 1200,
    warmupMs: 1500,
    lowFpsMs: 30,
    highFpsMs: 17,
    step: 0.05,
    minLevel: 0.33,
    maxLevel: 1.00,
    accMs: 0, frames: 0, lastEval: performance.now()
  };

  let scene, camera, glow, hl;

  const ROOM = { W: 16, D: 30, H: 10.6 };
  const MIN_RADIUS = 0.28;
  const MAX_RADIUS = 40;

  function createScene(){
    scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.06,0.06,0.06,1);

    camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/2.25, 11.5, new BABYLON.Vector3(0, ROOM.H*0.48, 0), scene);
    camera.attachControl(canvas, true);

    // Anti-flicker
    camera.minZ = 0.2;
    camera.maxZ = 200;

    camera.lowerBetaLimit = 0.1;
    camera.upperBetaLimit = Math.PI - 0.1;
    camera.lowerRadiusLimit = MIN_RADIUS;
    camera.upperRadiusLimit = MAX_RADIUS;

    camera.wheelDeltaPercentage = IS_MOBILE ? 0.18 : 0.22;
    camera.pinchDeltaPercentage = IS_MOBILE ? 0.006 : 0.008;
    camera.inertia = window.matchMedia('(prefers-reduced-motion: reduce)').matches ? 0.6 : 0.85;

    new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);

    glow = new BABYLON.GlowLayer("gl", scene, { blurKernelSize: IS_MOBILE ? 18 : 48 });
    glow.intensity = IS_MOBILE ? 0.5 : 0.9;

    hl = new BABYLON.HighlightLayer("hl", scene);

    buildRoom();
    buildLED();
    buildGalleryLogo();

    setupPicking();
    setupZoomUX();
    return scene;
  }

  /* =========================
     ROOM + LED
  ========================= */
  function unlit(hex){
    const m=new BABYLON.StandardMaterial("m",scene);
    m.diffuseColor=BABYLON.Color3.FromHexString(hex);
    m.disableLighting=true;
    return m;
  }
  function unlitTex(tex,{doubleSided=false}={}){
    const m=new BABYLON.StandardMaterial("mt",scene);
    m.disableLighting = true;
    m.diffuseTexture  = tex;
    m.emissiveTexture = tex;
    m.backFaceCulling = !doubleSided;
    if (tex) {
      tex.wrapU = tex.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
      tex.updateSamplingMode(BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
      tex.anisotropicFilteringLevel = MAX_ANISO || 4;
    }
    return m;
  }

  function buildRoom(){
    const floor = BABYLON.MeshBuilder.CreateGround("floor",{width:ROOM.W, height:ROOM.D},scene);
    floor.material = unlit("#151515");

    const back = BABYLON.MeshBuilder.CreatePlane("back",{width:ROOM.W, height:ROOM.H},scene);
    back.position.set(0, ROOM.H/2, -ROOM.D/2 + 0.01);
    back.material = unlit("#2b2b2b");
    back.rotation.y = 0;

    const front = BABYLON.MeshBuilder.CreatePlane("front",{width:ROOM.W, height:ROOM.H},scene);
    front.position.set(0, ROOM.H/2,  ROOM.D/2 - 0.01);
    front.material = unlit("#2b2b2b");
    front.rotation.y = Math.PI;

    const ceiling = BABYLON.MeshBuilder.CreateGround("ceiling",{width:ROOM.W, height:ROOM.D},scene);
    ceiling.position.y = ROOM.H;
    ceiling.rotation.x = Math.PI;
    ceiling.material = unlit("#0f0f10");

    const left = BABYLON.MeshBuilder.CreatePlane("leftWall",{width:ROOM.D, height:ROOM.H},scene);
    left.position.set(-ROOM.W/2 + 0.01, ROOM.H/2, 0);
    left.rotation.y = -Math.PI/2;
    left.material = unlit("#242424");

    const right = BABYLON.MeshBuilder.CreatePlane("rightWall",{width:ROOM.D, height:ROOM.H},scene);
    right.position.set( ROOM.W/2 - 0.01, ROOM.H/2, 0);
    right.rotation.y =  Math.PI/2;
    right.material = unlit("#242424");
  }

  function buildLED(){
    const n=new BABYLON.TransformNode("led",scene);
    const t=0.02, inw=0.1;
    const xL=-ROOM.W/2+inw, xR=ROOM.W/2-inw;
    const zF=ROOM.D/2-inw,  zB=-ROOM.D/2+inw;
    const y0=0.04, y1=ROOM.H-0.04;
    const mat=new BABYLON.StandardMaterial("ledMat",scene);
    mat.emissiveColor=BABYLON.Color3.FromHexString("#ffbdf6");
    mat.disableLighting=true;

    const seg=(a,b)=>{
      const d=BABYLON.Vector3.Distance(a,b);
      const m=BABYLON.MeshBuilder.CreateBox("ledSeg",{width:t,height:t,depth:d},scene);
      m.position=BABYLON.Vector3.Center(a,b);
      m.lookAt(b);
      m.rotation.x+=Math.PI;
      m.material=mat;
      m.isPickable=false;
      m.parent=n;
      glow.addIncludedOnlyMesh(m);
    };

    [[xL,y0,zF,xR,y0,zF],[xR,y0,zF,xR,y0,zB],[xR,y0,zB,xL,y0,zB],[xL,y0,zB,xL,y0,zF],
     [xL,y1,zF,xR,y1,zF],[xR,y1,zF,xR,y1,zB],[xR,y1,zB,xL,y1,zB],[xL,y1,zB,xL,y1,zF]
    ].forEach(([ax,ay,az,bx,by,bz])=>seg(new BABYLON.Vector3(ax,ay,az),new BABYLON.Vector3(bx,by,bz)));
    [[xL,zF],[xR,zF],[xR,zB],[xL,zB]].forEach(([x,z])=>seg(new BABYLON.Vector3(x,y0,z), new BABYLON.Vector3(x,y1,z)));
  }

  /* =========================
     Picking & zoom UX
  ========================= */
  function setupPicking(){
    scene.onPointerObservable.add((pi)=>{
      if (pi.type !== BABYLON.PointerEventTypes.POINTERPICK) return;
      if (!pi.pickInfo?.hit) return;
      const mesh = pi.pickInfo.pickedMesh;
      for(const wall of Object.keys(framesByWall)){
        for(const it of framesByWall[wall]){
          if (mesh === it.placard && it.data.url){ window.open(it.data.url,"_blank","noopener"); return; }
        }
      }
    }, BABYLON.PointerEventTypes.POINTERPICK);
  }

  function zoomToPointer(px, py, {scale=0.55, forceMin=false}={}){
    const pick = scene.pick(px, py);
    if(!pick?.hit) return;
    camera.target = pick.pickedPoint.clone();
    camera.radius = forceMin ? MIN_RADIUS : Math.max(MIN_RADIUS, camera.radius * scale);
  }

  function setupZoomUX(){
    const canvasEl = document.getElementById('renderCanvas');
    canvasEl.addEventListener("dblclick", ()=>{
      zoomToPointer(scene.pointerX, scene.pointerY, {
        scale: camera.radius < 1.2 ? 1.0 : 0.55,
        forceMin: camera.radius < 0.6
      });
    }, { passive:true });

    let lastTap = 0;
    canvasEl.addEventListener("touchend", (e)=>{
      const now = Date.now();
      const dt  = now - lastTap; lastTap = now;
      if (dt > 280) return;

      const t = e.changedTouches && e.changedTouches[0];
      if (!t) return;
      const rect = canvasEl.getBoundingClientRect();
      const x = t.clientX - rect.left;
      const y = t.clientY - rect.top;

      zoomToPointer(x, y, {
        scale: camera.radius < 1.2 ? 1.0 : 0.55,
        forceMin: camera.radius < 0.6
      });
    }, { passive:true });
  }

  /* =========================
     Obr√°zky / textury
  ========================= */
  function makeDT(name, w, h, genMipmaps=true) {
    const dt = new BABYLON.DynamicTexture(
      name,
      { width:w, height:h },
      scene,
      genMipmaps,
      BABYLON.Texture.TRILINEAR_SAMPLINGMODE
    );
    dt.wrapU = dt.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
    dt.hasAlpha = false;
    dt.anisotropicFilteringLevel = MAX_ANISO || 4;
    return dt;
  }

  function drawFitted(ctx,bmp,frameW,frameH){
    const targetR=frameW/frameH, r=bmp.width/bmp.height; let dw=TEX_SIZE,dh=TEX_SIZE,dx=0,dy=0;
    if(r>targetR){ dh=TEX_SIZE; dw=Math.round(dh*r); dx=Math.round((TEX_SIZE-dw)/2);}
    else{ dw=TEX_SIZE; dh=Math.round(dw/r); dy=Math.round((TEX_SIZE-dh)/2);}
    ctx.fillStyle="#000"; ctx.fillRect(0,0,TEX_SIZE,TEX_SIZE);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(bmp,0,0,bmp.width,bmp.height,dx,dy,dw,dh);
  }

  function drawChecker(ctx, w, h) {
    const tile = 32;
    for (let y = 0; y < h; y += tile) {
      for (let x = 0; x < w; x += tile) {
        const even = ((x / tile) + (y / tile)) % 2 === 0;
        ctx.fillStyle = even ? "#dcdcdc" : "#f4f4f4";
        ctx.fillRect(x, y, tile, tile);
      }
    }
  }

  const FRAME_SIZE = { W: 2, H: 2 };
  let FRAME_BOX_BORDER = 0.08;
  let FRAME_COLOR = "#717171";

  /* === FAKE st√≠nov√°n√≠ r√°m≈Ø ‚Äì MultiMaterial === */
  function makeGradDT(name, w, h, {from="#7a7a7a", to="#555", vertical=true, radial=false}={}){
    const dt = new BABYLON.DynamicTexture(name, {width:w, height:h}, scene, true, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
    const ctx = dt.getContext();
    ctx.clearRect(0,0,w,h);
    if (radial){
      const cx=w/2, cy=h/2, r=Math.sqrt(cx*cx+cy*cy);
      const g = ctx.createRadialGradient(cx, cy, r*0.15, cx, cy, r);
      g.addColorStop(0, from);
      g.addColorStop(1, to);
      ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
    } else {
      const g = vertical ? ctx.createLinearGradient(0,0,0,h) : ctx.createLinearGradient(0,0,w,0);
      g.addColorStop(0, from);
      g.addColorStop(1, to);
      ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
    }
    dt.update();
    dt.wrapU = dt.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
    dt.anisotropicFilteringLevel = MAX_ANISO || 4;
    return dt;
  }
  function lighten(col, f){ return new BABYLON.Color3(
    Math.min(1, col.r + (1-col.r)*f),
    Math.min(1, col.g + (1-col.g)*f),
    Math.min(1, col.b + (1-col.b)*f)
  );}
  function darken(col, f){ return new BABYLON.Color3(
    Math.max(0, col.r*(1-f)),
    Math.max(0, col.g*(1-f)),
    Math.max(0, col.b*(1-f))
  );}
  function makeShadedFrameBoxMultiMat(baseHex = FRAME_COLOR){
    const c = BABYLON.Color3.FromHexString(baseHex);
    const topLight    = lighten(c, 0.20).toHexString();
    const bottomDark  = darken(c,  0.25).toHexString();
    const sideMidTop  = lighten(c, 0.08).toHexString();
    const sideMidBot  = darken(c,  0.12).toHexString();
    const frontTop    = lighten(c, 0.12).toHexString();
    const frontBot    = darken(c,  0.18).toHexString();
    const backCol     = darken(c,  0.10).toHexString();

    const W=256,H=256;
    const dtFront = makeGradDT("frm_front",  W,H, {from:frontTop, to:frontBot, vertical:true});
    const dtBack  = makeGradDT("frm_back",   W,H, {from:backCol,  to:backCol,  vertical:true});
    const dtRight = makeGradDT("frm_right",  W,H, {from:sideMidTop,to:sideMidBot,vertical:true});
    const dtLeft  = makeGradDT("frm_left",   W,H, {from:sideMidTop,to:sideMidBot,vertical:true});
    const dtTop   = makeGradDT("frm_top",    W,H, {from:topLight,  to:topLight,  vertical:true});
    const dtBottom= makeGradDT("frm_bottom", W,H, {from:bottomDark,to:bottomDark,vertical:true});

    const mk = (name, dt)=>{
      const m = new BABYLON.StandardMaterial(name, scene);
      m.disableLighting = true;
      m.diffuseTexture  = dt;
      m.emissiveTexture = dt;
      m.specularColor   = new BABYLON.Color3(0,0,0);
      m.backFaceCulling = false;
      m.diffuseTexture.updateSamplingMode(BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
      return m;
    };
    const mats = [ mk("m_front",dtFront), mk("m_back",dtBack), mk("m_right",dtRight), mk("m_left",dtLeft), mk("m_top",dtTop), mk("m_bottom",dtBottom) ];
    const mm = new BABYLON.MultiMaterial("frameBoxMM", scene);
    mats.forEach(m => mm.subMaterials.push(m));
    return mm;
  }

  // Cedulka (plaketa)
  function drawPlacard(plac, data, rotY, planeW, planeH){
    const texWFull = TEX_SIZE;
    const texWTarget = IS_MOBILE ? Math.max(256, Math.min(1024, Math.round(texWFull * 0.5))) : texWFull;
    const texW = nearestPOT(texWTarget, IS_MOBILE ? 1024 : 2048);
    const texH = nearestPOT(Math.max(64, Math.round(texW * (planeH / planeW))), texW);

    const dt = makeDT("pl", texW, texH, !IS_MOBILE);
    const c = dt.getContext();
    c.fillStyle = "#6b6b6b";
    c.fillRect(0,0,texW,texH);

    const pad = Math.round(texH * 0.12);
    const maxW = texW - pad*2;

    c.fillStyle = "#ffffff";
    c.textAlign = "center";
    c.textBaseline = "top";
    const lineH = Math.round(texH * 0.34);
    const fontSize = Math.max(18, Math.round(lineH * 0.78));
    c.font = `600 ${fontSize}px Poppins, system-ui`;

    const text = (data.title || "(bez n√°zvu)").trim();
    const words = text.split(/\s+/);
    const lines = [];
    let buf = "";
    for (let w of words){
      const test = buf ? (buf + " " + w) : w;
      if (c.measureText(test).width <= maxW) buf = test;
      else { if (buf) lines.push(buf); buf = w; }
    }
    if (buf) lines.push(buf);

    const maxLines = 2;
    if (lines.length > maxLines){
      const keep = lines.slice(0, maxLines);
      let last = keep[maxLines-1];
      while (c.measureText(last + "‚Ä¶").width > maxW && last.length>0) last = last.slice(0,-1);
      keep[maxLines-1] = last + "‚Ä¶";
      lines.length = 0; Array.prototype.push.apply(lines, keep);
    }

    const blockH = lines.length * lineH;
    const startY = Math.max(pad, Math.round((texH - blockH)/2));
    lines.forEach((ln, i)=> c.fillText(ln, texW / 2, startY + i*lineH + Math.round(lineH*0.1)));

    dt.update();
    const mat = unlitTex(dt, { doubleSided:false });
    mat.zOffset = -2; // anti z-fighting
    plac.material = mat;
  }

  function normalOffset(rotY, dist){
    const nx = Math.sin(rotY) * dist;
    const nz = Math.cos(rotY) * dist;
    return new BABYLON.Vector3(nx, 0, nz);
  }

  function addFrame(pos, rotY=0, wall='front'){
    const box = BABYLON.MeshBuilder.CreateBox("frameBox", {
      width: FRAME_SIZE.W + FRAME_BOX_BORDER,
      height: FRAME_SIZE.H + FRAME_BOX_BORDER,
      depth: 0.06
    }, scene);
    box.position = pos.add(normalOffset(rotY, 0.0));
    box.rotation.y = rotY;
    box.isPickable = true;

    // Submeshe + MultiMaterial
    box.subMeshes = [];
    const indices = box.getIndices();
    const verticesCount = box.getTotalVertices();
    let idx = 0;
    const perFace = indices.length / 6;
    for (let f = 0; f < 6; f++){
      new BABYLON.SubMesh(f, 0, verticesCount, idx, perFace, box);
      idx += perFace;
    }
    box.material = makeShadedFrameBoxMultiMat(FRAME_COLOR);

    // P≈ôedn√≠ obrazov√° plocha
    const f = BABYLON.MeshBuilder.CreatePlane("frame", {
      width: FRAME_SIZE.W,
      height: FRAME_SIZE.H,
      sideOrientation: BABYLON.Mesh.FRONTSIDE
    }, scene);
    f.position = pos.add(normalOffset(rotY, 0.04));
    f.rotation.y = rotY + Math.PI;
    f.isPickable = true;

    const dt = makeDT("ph_img", TEX_SIZE, TEX_SIZE, true);
    const ctx = dt.getContext(); drawChecker(ctx, TEX_SIZE, TEX_SIZE); dt.update();
    const fMat = unlitTex(dt,{doubleSided:false});
    fMat.zOffset = -1;
    f.material  = fMat;

    // Cedulka
    const placW = FRAME_SIZE.W;
    const placH = Math.max(0.22, FRAME_SIZE.H * 0.10);
    const plac = BABYLON.MeshBuilder.CreatePlane("plac", {
      width: placW, height: placH, sideOrientation: BABYLON.Mesh.FRONTSIDE
    }, scene);
    plac.position = pos.add(new BABYLON.Vector3(0, -FRAME_SIZE.H*0.83, 0)).add(normalOffset(rotY, 0.03));
    plac.rotation.y = rotY + Math.PI;
    plac.isPickable = true;

    const data = { title: "(bez n√°zvu)", url: "", src: "" };
    drawPlacard(plac, data, rotY, placW, placH);

    return { frame:f, box, placard:plac, data, wall, rotY, pos };
  }

  /* =========================
     LOGO ‚Äì inline SVG (ostr√Ω + glow)
  ========================= */
  const GALLERY_LOGO_SVG = `
<svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 941.43 272.86" preserveAspectRatio="xMidYMid meet">
  <defs><style>.cls-1{fill:#daff3e;}</style></defs>
  <g>
    <path class="cls-1" d="M317.06,103.94h-76.71c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h76.71c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
    <path class="cls-1" d="M299.75,179.35c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l17.31-75.4c.46-2,2.46-3.25,4.45-2.79,2,.46,3.25,2.45,2.79,4.45l-17.31,75.4c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M222.8,180.12c-.28,0-.56-.03-.84-.1-2-.46-3.25-2.45-2.79-4.45l27.14-117.91c.46-2,2.45-3.25,4.46-2.79 2,.46 3.25,2.46 2.79,4.46l-27.14,117.91c-.4,1.72-1.93,2.88-3.62,2.88Z"/>
    <path class="cls-1" d="M439.3,179.34h-139.39c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h136.43l15.6-67.97h-70.53c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h75.2c1.13,0,2.2.52,2.91,1.4.71.89.97,2.04.72,3.15l-17.31,75.4c-.39,1.69-1.89,2.88-3.62,2.88Z"/>
    <path class="cls-1" d="M785.01,179.34c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l17.31-75.4c.39-1.69,1.89-2.88,3.62-2.88h76.96c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72h-74l-16.65,72.52c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M211.85,180.13l-170.7-.27c-2.05,0-3.71-1.67-3.71-3.72,0-2.05,1.67-3.71,3.72-3.71l170.7.27c2.05,0,3.71,1.67,3.71,3.72,0,2.05-1.67,3.71-3.72,3.71Z"/>
    <path class="cls-1" d="M72.27,221.31c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l26.94-117.36c.46-2,2.46-3.25,4.45-2.79,2,.46,3.25,2.45,2.79,4.45l-26.94,117.36c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M784.97,179.34h-141.2c-1.13,0-2.2-.52-2.91-1.4-.71-.89-.97-2.04-.72-3.15l17.31-75.4c.39-1.69,1.89-2.88,3.62-2.88h76.41c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72h-73.45l-15.6,67.97h136.53c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
    <path class="cls-1" d="M158.76,180.12c-.28,0-.55-.03-.83-.1-2-.46-3.25-2.45-2.79-4.45l16.44-71.63h-72.37c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h77.03c1.13,0,2.2.52,2.91,1.4.71.89.97,2.04.71,3.15l-17.49,76.18c-.39,1.72-1.93,2.89-3.62,2.89Z"/>
    <path class="cls-1" d="M222.74,180.13l-182.02-.27c-2.05,0-3.71-1.67-3.71-3.72,0-2.05,1.67-3.71,3.72-3.71l182.02.27c2.05,0,3.71,1.67,3.71,3.72,0,2.05-1.67,3.71-3.72,3.71Z"/>
    <path class="cls-1" d="M602.74,212.29c-.55,0-1.09-.12-1.61-.37-.76-.36-1.35-.96-1.71-1.68l-103.95-136.78-129.09,105.46c-1.59,1.3-3.93,1.06-5.23-.53-1.3-1.59-1.06-3.93.53-5.23l131.89-107.74c.39-.36.86-.64,1.38-.81,1.5-.48,3.14.02,4.1,1.28l104.39,137.36 131.99-105.98c1.6-1.29,3.94-1.03,5.22.57 1.28,1.6 1.03,3.94-.57,5.22l-135.02,108.4c-.67.54-1.5.82-2.33.82Z"/>
  </g>
  <g>
    <path class="cls-1" d="M596.11,104.5h-75.2c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h75.2c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
    <path class="cls-1" d="M577.73,179.9h-74.12c-2.05,0-3.72-1.66-3.72-3.72s1.66-3.72,3.72-3.72h74.12c2.05,0,3.72,1.66,3.72,3.72s-1.66,3.72-3.72,3.72Z"/>
  </g>
</svg>`;
  const LOGO_ASPECT = 941.43 / 202.86;
  const LOGO_SCALE = 0.30;
  const FRONT_BACK_OFFSET = 0.25;
  const LOGO_HEIGHT_M = 6.30;
  const GLOW_BLUR_PX = 18;

  function buildGalleryLogo(){
    const img = new Image();
    img.src = "data:image/svg+xml;utf8," + encodeURIComponent(GALLERY_LOGO_SVG);
    img.onload = () => {
      const SIZE = 1024;
      const dt  = new BABYLON.DynamicTexture("logoDT",{width:SIZE,height:SIZE},scene,true);
      const ctx = dt.getContext();
      const maxW = SIZE * 0.92;
      const w = maxW, h = Math.round(maxW / LOGO_ASPECT);
      const x = Math.round((SIZE - w)/2), y = Math.round((SIZE - h)/2);
      ctx.clearRect(0,0,SIZE,SIZE); ctx.drawImage(img, x, y, w, h); dt.update();

      const glowDT = new BABYLON.DynamicTexture("logoGlowDT",{width:SIZE,height:SIZE},scene,true);
      const gc = glowDT.getContext();
      gc.clearRect(0,0,SIZE,SIZE); gc.filter = `blur(${GLOW_BLUR_PX}px)`; gc.drawImage(img, x, y, w, h); glowDT.update();

      const sharpMat = new BABYLON.StandardMaterial("logoSharpMat", scene);
      sharpMat.disableLighting = true; sharpMat.diffuseTexture  = dt; sharpMat.opacityTexture  = dt;
      sharpMat.emissiveColor   = new BABYLON.Color3(1,1,1); sharpMat.backFaceCulling = false;

      const glowMat = new BABYLON.StandardMaterial("logoGlowMat", scene);
      glowMat.disableLighting  = true; glowMat.emissiveTexture  = glowDT; glowMat.opacityTexture   = glowDT;
      glowMat.emissiveColor    = new BABYLON.Color3(1,1,1); glowMat.backFaceCulling  = false;

      const logoW = ROOM.W * LOGO_SCALE;
      const logoH = LOGO_HEIGHT_M;
      const yPos = ROOM.H*0.55 + FRAME_SIZE.H*0.95 + 0.80;

      function placeLogo(z, rotY, idx){
        const g = BABYLON.MeshBuilder.CreatePlane(`logoGlow_${idx}`, { width:logoW, height:logoH }, scene);
        g.position.set(0, yPos, z - Math.sign(z)*0.005); g.rotation.y = rotY; g.material = glowMat; glow.addIncludedOnlyMesh(g);

        const s = BABYLON.MeshBuilder.CreatePlane(`logoSharp_${idx}`, { width:logoW, height:logoH }, scene);
        s.position.set(0, yPos, z + Math.sign(z)*0.005); s.rotation.y = rotY; s.material = sharpMat;
      }
      placeLogo(-ROOM.D/2 + FRONT_BACK_OFFSET, Math.PI, 0);
      placeLogo( ROOM.D/2 - FRONT_BACK_OFFSET, 0,       1);
      hint("Logo (inline SVG) zobrazeno ‚úî  (glow aktivn√≠)");
    };
    img.onerror = (e) => { console.error("Logo SVG ne≈°lo dek√≥dovat.", e); hint("Chyba: logo SVG ne≈°lo dek√≥dovat."); };
  }

  /* =========================
     Gener√°tor r√°m≈Ø + data
  ========================= */
  const framesByWall = { back: [], front: [], left: [], right: [] };

  function distributeCenters(min, max, count, frameW){
    if (count <= 1) return [ (min+max)/2 ];
    const span = max - min;
    const totalFramesWidth = count * frameW;
    let gap = (span - totalFramesWidth) / (count - 1);
    const MIN_GAP = 0.05;
    if (gap < MIN_GAP) gap = Math.max(gap, MIN_GAP);
    const centers = [];
    let x = min + frameW/2;
    for (let i = 0; i < count; i++) { centers.push(x); x += frameW + gap; }
    if (centers[centers.length-1] > max - frameW/2 + 1e-6) {
      const step = (max - min) / (count - 1);
      centers.length = 0;
      for (let i=0;i<count;i++) centers.push(min + i*step);
    }
    return centers;
  }

  function createFixedFramesForWall(wall, count, centerY, safeWall, cornerSafe){
    const rotY =
      wall==='front' ? Math.PI :
      wall==='back'  ? 0 :
      wall==='left'  ? Math.PI/2 :
      wall==='right' ? -Math.PI/2 : 0;

    const axisX  = (wall==='front'||wall==='back');
    const length = axisX ? ROOM.W : ROOM.D;

    const min = -length/2 + safeWall + cornerSafe;
    const max =  length/2 - safeWall - cornerSafe;

    const centers = distributeCenters(min, max, count, FRAME_SIZE.W);

    framesByWall[wall].forEach(it => { it.frame.dispose(); it.box.dispose(); it.placard.dispose(); });
    framesByWall[wall] = [];

    centers.forEach(val=>{
      const pos = axisX
        ? new BABYLON.Vector3(val, centerY, (wall==='front' ? ROOM.D/2 - 0.03 : -ROOM.D/2 + 0.03))
        : new BABYLON.Vector3((wall==='right' ? ROOM.W/2 - 0.03 : -ROOM.W/2 + 0.03), centerY, val);
      const it = addFrame(pos, rotY, wall);
      framesByWall[wall].push(it);
    });
  }

  const DATA = {
    front: [
      { img: "./assets/one.jpg",   label: "Produkt A", href: "https://everpress.com/the-future-phaser-collection2" },
      { img: "./assets/two.jpg",   label: "Produkt B", href: "https://example.com/b" },
      { img: "./assets/three.jpg", label: "Produkt C", href: "https://example.com/c" },
      { img: "./assets/one.jpg",   label: "Produkt D", href: "https://example.com/d" }
    ],
    back: [
      { img: "./assets/one.jpg",   label: "Back A", href: "https://example.com/a" },
      { img: "./assets/two.jpg",   label: "Back B", href: "https://example.com/b" },
      { img: "./assets/three.jpg", label: "Back C", href: "https://example.com/c" },
      { img: "./assets/one.jpg",   label: "Back D", href: "https://example.com/d" }
    ],
    left: [
      { img: "./assets/one.jpg",   label: "Lev√° 1", href: "https://example.com/left-1" },
      { img: "./assets/two.jpg",   label: "Lev√° 2", href: "https://example.com/left-2" },
      { img: "./assets/three.jpg", label: "Lev√° 3", href: "https://example.com/left-3" },
      { img: "./assets/one.jpg",   label: "Lev√° 4", href: "https://example.com/left-4" },
      { img: "./assets/two.jpg",   label: "Lev√° 5", href: "https://example.com/left-5" },
      { img: "./assets/three.jpg", label: "Lev√° 6", href: "https://example.com/left-6" },
      { img: "./assets/one.jpg",   label: "Lev√° 7", href: "https://example.com/left-7" }
    ],
    right: [
      { img: "./assets/two.jpg",   label: "Prav√° 1", href: "https://example.com/right-1" },
      { img: "./assets/three.jpg", label: "Prav√° 2", href: "https://example.com/right-2" },
      { img: "./assets/one.jpg",   label: "Prav√° 3", href: "https://example.com/right-3" },
      { img: "./assets/two.jpg",   label: "Prav√° 4", href: "https://example.com/right-4" },
      { img: "./assets/three.jpg", label: "Prav√° 5", href: "https://example.com/right-5" },
      { img: "./assets/one.jpg",   label: "Prav√° 6", href: "https://example.com/right-6" },
      { img: "./assets/two.jpg",   label: "Prav√° 7", href: "https://example.com/right-7" }
    ]
  };

  function assignDataAllWalls(data){
    const loadLocal = (url, targetItem)=>{
      targetItem.data.src = url;
      const img = new Image();
      if (!/^(\.|\/)/.test(url)) img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.onload = ()=>{
        const dt = makeDT("imgDT"+Math.random(), TEX_SIZE, TEX_SIZE, !IS_MOBILE);
        const ctx=dt.getContext(); drawFitted(ctx,img,FRAME_SIZE.W,FRAME_SIZE.H); dt.update();
        const mat = unlitTex(dt,{doubleSided:false});
        mat.zOffset = -1;
        targetItem.frame.material = mat;
        autosave();
      };
      img.onerror = ()=>{
        const dt = makeDT("imgDT"+Math.random(), TEX_SIZE, TEX_SIZE, false);
        const ctx = dt.getContext();
        drawChecker(ctx, TEX_SIZE, TEX_SIZE);
        dt.update();
        targetItem.frame.material = unlitTex(dt,{doubleSided:false});
      };
      img.src = url;
    };

    ["front","back","left","right"].forEach(side=>{
      const items = data[side] || [];
      const arr   = framesByWall[side] || [];
      const n = Math.min(items.length, arr.length);
      for (let i=0;i<n;i++){
        const it = arr[i], d = items[i] || {};
        it.data.src   = d.img   || it.data.src || "";
        it.data.title = d.label || it.data.title || "(bez n√°zvu)";
        it.data.url   = d.href  || it.data.url || "";
        drawPlacard(it.placard, it.data, it.rotY, it.placard._width || FRAME_SIZE.W, it.placard._height || Math.max(0.22, FRAME_SIZE.H*0.10));

        if (d.img){
          if (IS_MOBILE) setTimeout(()=>loadLocal(d.img, it), i*80); else loadLocal(d.img, it);
        }
      }
    });
  }

  function autosave(){
    try{
      const data = collectGalleryData();
      localStorage.setItem('draftGalleryJson', JSON.stringify(data));
    }catch(e){ /* ignore */ }
  }

  async function applyLayoutFromUI() {
    const YCENTER = ROOM.H * 0.55;
    const safeWall   = +$("safeWall").value   || 1;
    const cornerSafe = +$("cornerSafe").value || 1;
    FRAME_SIZE.W     = +$("frmW").value       || 2;
    FRAME_SIZE.H     = +$("frmH").value       || 2;
    FRAME_BOX_BORDER = +$("frmBorder").value  || 0.2;
    FRAME_COLOR      = $("frmColor").value    || "#717171";

    createFixedFramesForWall('front', +$("cntFront").value||0,  YCENTER, safeWall, cornerSafe);
    createFixedFramesForWall('back',  +$("cntBack").value||0,   YCENTER, safeWall, cornerSafe);
    createFixedFramesForWall('left',  +$("cntLeft").value||0,   YCENTER, safeWall, cornerSafe);
    createFixedFramesForWall('right', +$("cntRight").value||0,  YCENTER, safeWall, cornerSafe);

    const data = (window.galleryData && Object.keys(window.galleryData).length) ? window.galleryData : DATA;
    assignDataAllWalls(data);

    try {
      const applied = collectGalleryData();
      window.lastAppliedGalleryData = applied;
      localStorage.setItem('draftGalleryJson', JSON.stringify(applied));
    } catch(e) { /* ignore */ }

    autosave();
    hint("Layout aplikov√°n.");
  }

  let applying = false;
  $("btnApplyLayout").addEventListener("click", async ()=>{
    if (applying) return;
    applying = true;
    try { await applyLayoutFromUI(); }
    finally { applying = false; }
  });

  $("btnResetCam").addEventListener("click", ()=>{
    camera.target.set(0, ROOM.H*0.48, 0);
    camera.radius=11.5;
    hint("Kamera resetov√°na.");
  });

  // === VIEW reset kamery ‚Äì jen kamera (nez√°visl√© na SC) ===
  function resetCameraViewOnly(){
    if (!camera) return;
    camera.target.set(0, ROOM.H*0.48, 0);
    camera.radius = 11.5;
    camera.alpha  = -Math.PI/2;
    camera.beta   =  Math.PI/2.25;
  }
  const resetCamIcon = document.getElementById('resetCamIcon');
  if (resetCamIcon){
    resetCamIcon.addEventListener('click', resetCameraViewOnly);
    resetCamIcon.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); resetCameraViewOnly(); }
    });
  }

  // Boot
  createScene();

  // SC ovladaƒçe (lazy-load a≈æ na Play)
  bindAdminControls();
  bindViewControls();

  // Render loop + mobiln√≠ auto-quality sledov√°n√≠
  engine.runRenderLoop(()=>{
    if (!scene) return;
    scene.render();

    if (AutoScale.enabled){
      const now = performance.now();
      AutoScale.accMs += engine.getDeltaTime();
      AutoScale.frames++;

      if (now - AutoScale.lastEval > AutoScale.windowMs && now > AutoScale.warmupMs){
        const avgMs = AutoScale.accMs / AutoScale.frames;
        let changed = false;

        if (avgMs > AutoScale.lowFpsMs && currentScaleLevel < AutoScale.maxLevel){
          currentScaleLevel = Math.min(AutoScale.maxLevel, currentScaleLevel + AutoScale.step);
          changed = true;
        } else if (avgMs < AutoScale.highFpsMs && currentScaleLevel > AutoScale.minLevel){
          currentScaleLevel = Math.max(AutoScale.minLevel, currentScaleLevel - AutoScale.step);
          changed = true;
        }

        if (changed){
          applyHardwareScale(currentScaleLevel);
          if (glow){
            const k = currentScaleLevel; // 0.33..1
            glow.blurKernelSize = Math.round( (IS_MOBILE ? 18 : 48) * (0.9 + 0.2*(1 - (k-0.33)/(1-0.33))) );
          }
        }
        AutoScale.accMs = 0; AutoScale.frames = 0; AutoScale.lastEval = now;
      }
    }
  });

  // Resize
  function handleResize(){
    applyHardwareScale();
    engine.resize(true);
  }
  window.addEventListener("resize", handleResize, { passive:true });
  window.addEventListener("orientationchange", handleResize);

  // iOS ‚Äì zamezit str√°nkov√©mu pinch/gesture (ru≈°√≠ canvas)
  document.addEventListener('gesturestart', e => { if (IS_IOS) { e.preventDefault(); } }, { passive:false });

  // Start m√≥d: VIEW (viz body.class="view")
  setMode(MODE.VIEW);

  (async function boot(){
    await ensurePoppins();
    await applyLayoutFromUI();
    handleResize();
    console.log("‚úî Boot hotovo ‚Äì start ve VIEW. Kl√°vesy: 'A' ADMIN ¬∑ 'V' VIEW (VIEW ovladaƒçe vpravo dole). Ikona vpravo dole resetuje kameru.");
  })();

  </script>
</body>
</html>
``
